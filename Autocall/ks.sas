/* MACRO %KS
Version: 1.03
Author: Daniel Mastropietro
Created: 16-Nov-04
Modified: 24-Aug-05

DESCRIPTION:
Computes KS for a scoring model with a dichotomous target variable, and the percentile
of the score at which the KS occurs.
Optionally, a plot of the cumulative distribution function of the score for each
value of the target variable is made.

USAGE:
%KS(
	data,			*** Input dataset.
	target=y,		*** Dichotomous target variable.
	score=p,		*** Score variable.
	descending=1,	*** Whether to rank sort the score in descending or ascending order.
	min=0,			*** Minimum possible value of the score variable (for plotting purposes).
	max=1,			*** Maximum possible value of the score variable (for plotting purposes).
	by=,			*** By variables.
	plot=0,			*** Show CDF for both target events with KS?
	bands=1,		*** Show the confidence bands for the CDFs? 
	confidence=0.95,*** Confidence level for the confidence bands for the CDFs.
	label=,			*** List of the 2 labels to be used in the CDF plot for each level of
					*** the target variable, listed in the order given by the ordered levels.
	color=,			*** List of the 2 colors to be used in the CDF plot for each level of
					*** the target variable, listed in the order set by the ordered levels.
	points=1,		*** Show points indicating plotting points?
	out=,			*** Output dataset with the data necessary to make the CDF plots.
	outks=,			*** Output dataset with the KS value.
	log=1);			*** Show messages in the log?

REQUIRED PARAMETERS:
- data:			Input dataset containing the score obtained in the scoring model.
				Data options can be specified as in a data= SAS option.

OPTIONAL PARAMETERS:
- target:		Target variable used in the model.
				default: y

- score:		Variable containing the score generated by the scoring model.
				It is assumed that the score variable only takes NON-NEGATIVS values.
				Typically a probability.
				default: p

- descending:	Whether to compute the percentiles of the score variable in ascending or
				desceding sequence. This parameter switches the position of the gains curve
				for the events with respect to the naive line.
				Possible values: 0 => Ascending, 1 => Descending
				default: 1

- min:			Minimum possible value of the score.
				This is used for plotting purposes, so that the score CDFs shown start
				at this value.
				default: 0

- max:			Maximum possible value of the score.
				This is used for plotting purposes, so that the score CDFs shown reach
				this value.
				default: 1

- by:			List of by variables by which the analysis is performed.

- plot:			Show the plot of the score CDFs by each value of the target variable?
				Possible values: 0 => No, 1 => Yes
				default: 0

- bands:		Whether to show the confidence bands for the CDFs.
				Possible values: 0 => No, 1 => Yes
				default: 1

- confidence:	Confidence level for the CDF confidence bands. That is, 
				a (&confidence)*100% confidence band is shown for each plotted CDF.
				Possible values are: 0.80, 0.90, 0.95, 0.98 and 0.99.
				default: 0.95 (i.e. 95% confidence bands are shown)

- label:		Unquoted list of the 2 labels to use in the legend indicating to what value of
				the target variable each CDF corresponds. The labels should be listed in the
				order of the ordered values of the target variable. For example, if the values
				of the target variables are 0 and 1, the first label corresponds to the value 0.
				By default, the label is of the form
				<score-variable>=<level> (ex: DQ90=0, DQ90=1)
				Ex: label=Good Bad

- color:		Same as option 'label' but this option specifies the colors to use for each CDF.
				default: blue red

- points:		Show points indicating plotting points in the graph?
				Possible values: 0 => No, 1 => Yes.
				default: 1

- out:			Output dataset with the data necessary to make the CDF plots.
				It contains the following columns:
				- <target>: Value taken by the target variable.
				- <score>: Score variable.
				- CDF: Cumulative Distribution Function of the score.
				- CDFLower<confidence*100>: Lower end of the CDF confidence band.
				- CDFUpper<confidence*100>: Upper end of the CDF confidence band.
				- rank: Score rank (from higer to lower values).
				- RankCDF: Cumulative Distribution Function of the score rank.
				- RankCDFLower<confidence*100>: Lower end of the Rank CDF confidence band.
				- RankCDFUpper<confidence*100>: Upper end of the Rank CDF confidence band.
				Note: <zzz> indicates the value of parameter ZZZ passed to the macro.

- outks:		Output dataset containing the following variables:
				- KS
				- Rank: Rank of the score variable at which the KS occurs.
				- <score-variable>: Value of the score variable at which the KS occurs.
				If this parameter is passed, nothing is shown in the output window.

- log:			Show messages in the log?
				Possible values: 0 => No, 1 => Yes
				default: 1

NOTES:
1.- Confidence bands for the CDFs are included in the plot if requested.
2.- When confidence bands are requested, the analysis variable is assumed to be non-negative
because the LIFETEST procedure is used to compute the confidence bands.

OTHER MACROS AND MODULES USED IN THIS MACRO:
- %Callmacro
- %CheckInputParameters
- %CreateGroupVar
- %CreateInteractions
- %DefineSymbols
- %Getnobs
- %MakeListFromVar
- %ResetSASOptions
- %SetAxis
- %SetSASOptions

EXAMPLES:
1.- %KS(scoredData, target=dq90, score=p, plot=1, confidence=0.90, label=Good Bad, color=green red);
This computes the KS for the scored model whose score is stored in variable P of dataset
SCOREDDATA. The target variable for the model is DQ90.
Plot of the score CDFs for each value of the target variable are shown together with 90%
confidence bands.
The label for the smallest target value is 'Good' and for the largest target value
is 'Bad', and the colors are 'green' and 'red' respectively.
*/

/*
PENDIENTE:
- (17/11/04) Falta probar el BY=.
- (2/12/04) Falta agregar el parametro BANDS=1 (como en %EvaluationChart) para tener la opcion
de que se muestren o no se muestren las bandas de confianza de las CDFs.
*/
%MACRO KS(	data,
			target=y,
			score=p,
			descending=1,
			min=min,
			max=max,

			by=,
			format=,	/* Esto fue un intento de pasar un formato para las BY variables pero no funciono al invocar la macro %CreateGroupVar con este parametro */

			plot=0,
			bands=1,
			confidence=0.95,
			label=,
			color=,
			points=1,

			out=,
			outks=,

			log=1,
			help=0) / des="Computes the KS for a scoring model or variable";

/*----- Macro to display usage -----*/
%MACRO ShowMacroCall;
	%put KS: The macro call is as follows:;
	%put %nrstr(%KS%();
	%put data , (REQUIRED) %quote(      *** Input dataset.);
	%put target=y , %quote(             *** Dichotomous target variable.);
	%put score=p , %quote(              *** Score variable.);
	%put min=0 , %quote(                *** Minimum possible value of the score variable.);
	%put max=1 , %quote(                *** Maximum possible value of the score variable.);
	%put;
	%put by= , %quote(                  *** By variables.);
	%put;
	%put plot=0 , %quote(               *** Make plot of cumulative distribution functions (CDF)?);
	%put bands=1 , %quote(              *** Show the confidence bands for the CDFs?);
	%put confidence=0.95 , %quote(      *** Confidence level for the CDF confidence bands.);
	%put label= , %quote(               *** List of the 2 labels to be used in the CDF plot for each level of);
	%put %quote(                            the target variable, listed in the order set by the ordered levels);
	%put points=, %quote(               *** Show points indicating plotting points?);
	%put color= , %quote(               *** List of the 2 colors to be used in the CDF plot for each level of);
	%put %quote(                            the target variable, listed in the order set by the ordered levels.);
	%put;
	%put out=, %quote(                  *** Output dataset with the data necessary to make the CDF plots.);
	%put outks=, %quote(                *** Output dataset with the KS value.);
	%put;
	%put log=1) , %quote(               *** Show messages in the log?);
%MEND ShowMacroCall;

%if &help %then %do;
	%ShowMacroCall;
%end;
%else %if ~%CheckInputParameters(data=&data , var=&target &score, check=by, macro=KS) %then %do;
	%ShowMacroCall;
%end;
%else %do;
/************************************* MACRO STARTS ******************************************/
/* Local variables declaration */
%local i;
%local error;
%local _by_ nro_groups;
%local byvalues title2;
%local data_name;
%local outks_name out_name;
%local dsid nobs nobs_left nobs_removed rc varnum vartype;
%local plotstr;			%* Plotting string;
%local missing;			%* String defining a missing value;
%local _descending_;	%* <Empty> or = descending whether DESCENDING = 0 or 1 respectively;
%local ks ks_rank;		%* Value of the KS;
%local at at_rank;		%* Score at which the KS occurs;
%local rank;			%* Rank of the score variable at which the KS occurs;
%local value1 value2;	%* Values taken by the target variable;
%local label1 label2;	%* Labels to use in the plot for each level of the target variable;

%SetSASOptions;

%* Showing input parameters;
%if &log %then %do;
	%put;
	%put KS: Macro starts;
	%put;
	%put KS: Input parameters:;
	%put KS: - Input dataset = %quote(&data);
	%put KS: - target = %quote(       &target);
	%put KS: - score = %quote(        &score);
	%put KS: - min = %quote(          &min);
	%put KS: - max = %quote(          &max);
	%put KS: - by = %quote(           &by);
	%put KS: - plot = %quote(         &plot);
	%put KS: - bands = %quote(        &bands);
	%put KS: - confidence = %quote(   &confidence);
	%put KS: - label = %quote(        &label);
	%put KS: - color = %quote(        &color);
	%put KS: - points = %quote(       &points);
	%put KS: - out = %quote(          &out);
	%put KS: - outks = %quote(        &outks);
	%put KS: - log = %quote(          &log);
	%put;
%end;

/*----------------------------- Parsing input parameters ------------------------------------*/
%let error = 0;

%*** DATA;
%let data_name = %scan(&data, 1, '(');
%* Check the type of the target variable and define the corresponding missing value;
%* (Note: I could use macro variable %GetVarType but since I also need the number of obs
%* in the dataset, I do not call %GetVarType because I would need to call %callmacro
%* to get the number of obs and the input dataset would be opened and closed twice,
%* instead of only once;
%let dsid = %sysfunc(open(&data));			%* Note that data options are accepted here;
%let nobs = %sysfunc(attrn(&dsid,nobs));
%let varnum = %sysfunc(varnum(&dsid,&target));
%let vartype = %sysfunc(vartype(&dsid,&varnum));
%let rc = %sysfunc(close(&dsid));
%if %upcase(&vartype) = C %then	
	%let missing = " ";
%else
	%let missing = .;

%* Read input dataset and,
%* - execute data options
%* - eliminate missing values of the target variable and the score variable
%* - keep only necessary variables;
%if %ExistOption(&data, where) %then %do;
	%* This is necessary because if there is a where data option in &data,
	%* there will be conflict with the where statement OUTSIDE the data option;
	data _KS_data_;
		set &data;
		&format;
		keep &by &target &score;
	run;
	data _KS_data_;
		set _KS_data_;
		&format;
		where &target ~= &missing and &score ~= .;
	run;
%end;
%else %do;
	data _KS_data_;
		set &data;
		where &target ~= &missing and &score ~= .;
		&format;
		keep &by &target &score;
	run;
%end;
%callmacro(getnobs, _KS_data_ return=1, nobs_left);
%let nobs_removed = %eval(&nobs - &nobs_left);
%if &log %then %do;
	%put KS: Nro. of observations in the input dataset: &nobs;
	%put KS: Nro. of observations removed due to filters and missing values of target or score: &nobs_removed;
	%put KS: Nro. observations left in the analysis: &nobs_left;
	%put;
%end;

%*** TARGET=;
%* Check whether the target variable is dichotomous (note that missing values
%* have already been removed from the input dataset);
proc freq data=_KS_data_ noprint;
	tables &target / out=_KS_freq_;
run;
%callmacro(getnobs, _KS_freq_ return=1, nobs);
%if &nobs > 2 %then %do;
	%put KS: ERROR - The number of values taken by the target variable is more than 2.;
	%let error = 1;
%end;
%else %do;
	%let dsid = %sysfunc(open(_KS_freq_));
	%let varnum = %sysfunc(varnum(&dsid, &target));
	%let vartype = %sysfunc(vartype(&dsid, &varnum));
	%let rc = %sysfunc(fetch(&dsid, 1));
	%let value1 = %sysfunc(getvar&vartype(&dsid, &varnum));
		%** Note that no spaces are left by function VARTYPE, so that the statement
		%** getvar&vartype in the %let value1 statement works fine;
	%let rc = %sysfunc(fetch(&dsid, 2));
	%let value2 = %sysfunc(getvar&vartype(&dsid, &varnum));
	%let rc = %sysfunc(close(&dsid));
	%* Add quotes to the values of VALUE1 and VALUE2 when the target variable is character
	%* to avoid the error of incompatible variables;
	%if %upcase(&vartype) = C %then %do;
		%let value1 = "&value1";
		%let value2 = "&value2";
	%end;
%end;

%*** BY=;
%let byst = ;
%let _by_ = ;
%if %quote(&by) ~= %then %do;
	%let byst = by &by;
	%* Create a group ID if there is more than one by variable;
	%if %GetNroElements(&by) > 1 %then %do;
		%* Create a new variable (_GROUPID_) identifying each group, which is used to facilitate the
		%* annotation of the plots. Note that the dataset is sorted by the by variables since SORT=1.
		%* This is not a problem because I still sort by the by variables below;
		%* NOTA: El FORMAT= option fue un intento de que las BY variables tuvieran formato, pero no anduvo;
		%CreateGroupVar(_KS_data_, by=&by, /*format=&format,*/ name=_BY_, ngroups=nro_groups_global, sort=1, log=0);
		%let nro_groups = &nro_groups_global;
		%symdel nro_groups_global; quit;	%* Delete global macro variable created in %CreateGroupVar;
		%let _by_ = _BY_;					%* This is the by variable used in the annotate dataset;
	%end;
	%else %do;
		%* Count the number of by groups;
		proc freq data=_KS_data_(keep=&by) noprint;
			&format;
			tables &by / out=_KS_freq_;
		run;
		%Callmacro(getnobs, _KS_freq_ return=1, nro_groups);
		%* Create the auxiliary variable _BY_, as numeric variable, because this is used in the
		%* plot statements to define each group to plot;
		%Merge(_KS_data_, _KS_freq_(keep=&by), by=&by, sort=1,
			   condition=%quote(
							retain _by_ 0;
							if first.&by then _BY_ = _BY_ + 1;), log=0);
		%** NOTE: The output dataset is sorted by the by variables because SORT=1. This is not
		%** a problem because I still sort by the by variables below;
		%let _by_ = _BY_;
	%end;
%end;

%*** DESCENDING=;
%let _descending_ = ;
%if &descending %then	
	%let _descending_ = descending;

%*** CONFIDENCE=;
%if &confidence ~= 0.80 and
	&confidence ~= 0.90 and
	&confidence ~= 0.95 and
	&confidence ~= 0.98 and
	&confidence ~= 0.99 %then %do;
	%put KS: WARNING - The requested confidence level for the CDF confidence bands is not valid.;
	%put KS: The default value (0.95) will be used.;
%end;
/*-------------------------------------------------------------------------------------------*/

%if ~&error %then %do;
/*
%* This is the procedure that computes the KS but it is not useful because the point
%* at which the KS occurs is not stored anywhere!!! So, I have to do my own computation,
%* as I do below;
proc npar1way data=_KS_data_ EDF noprint;
	&byst;
	class &target;
	var &score;
	output out=_KS_out_;
run;
*/

%* Number of valid observations by by variables. This is necessary to compute the quantiles
%* of the Kolmogorov Test Statistic used to compute the CDF condifence limits, as done below.
%* I also compute the minimum and maximum of the SCORE variable in case parameters MIN and
%* MAX are set to min and max respectively (this implies that the minimum and maximum possible
%* values of the score variable are not preset, but rather are determined from the data);
proc sort data=_KS_data_;
	by &by &target;
run;
proc means data=_KS_data_ n min max noprint;
	by &by &target;
	var &score;
	output out=_KS_n_(drop=_TYPE_ _FREQ_) n=n min=min max=max;
run;
%* Compute the number of observations for each analysis population;
proc means data=_KS_n_ sum noprint;
	%if %quote(&by) ~= %then %do;
	by &by;
	%end;
	var n;
	output out=_KS_popsize_(drop=_TYPE_ _FREQ_) sum=n;
run;

%* Compute the minimum and maximum values of the SCORE variable when MIN=MIN and MAX=MAX;
%if %quote(%upcase(&min)) = MIN or %quote(%upcase(&max)) = MAX %then %do;
	%if %quote(%upcase(&min)) ~= MIN %then
		%let min = 0;
	%if %quote(%upcase(&max)) ~= MAX %then
		%let max = 1;
	data _NULL_;
		set _KS_n_ end=lastobs;
		retain _min_ _max_ .;
		%if %quote(%upcase(&max)) = MAX %then %do;
		if _max_ = . or max > _max_ then
			_max_ = max;
		%end;
		%if %quote(%upcase(&min)) = MIN %then %do;
		if _min_ = . or min < _min_ then
			_min_ = min;
		%end;
		if lastobs then do;
			%* Set the value of the macro variables &min and &max;
			%if %quote(%upcase(&min)) = MIN %then %do;
			call symput ('min', left(trim(_min_)));
			%end;
			%if %quote(%upcase(&max)) = MAX %then %do;
			call symput ('max', left(trim(_max_)));
			%end;
		end;
	run;
%end;

%* Define a dataset with the data necessary to compute the condifence bands of the CDFs;
%* Ref: "Practical Nonparametric Statistics", Conover (1980), pag. 353 and Table A14;
%* This data are valid when n > 40, where n is the number of observations involved in the
%* computation of the CDF;
data _KS_KolmogorovBandWidths_;
	format confidence percent7.1;
	set _KS_n_;
	confidence = 0.80; width = 1.07 / sqrt(n); output;
	confidence = 0.90; width = 1.22 / sqrt(n); output;
	confidence = 0.95; width = 1.36 / sqrt(n); output;
	confidence = 0.98; width = 1.52 / sqrt(n); output;
	confidence = 0.99; width = 1.63 / sqrt(n); output;
run;

%* Compute rank of the score variable (in descending or ascending order, depending on parameter
%* DESCENDING) in order to compute the Gains Chart for each target value and its confidence bands;
proc rank data=_KS_data_(keep=&_by_ &by &target &score) out=_KS_rank_ &_descending_ fraction;
	&byst;
	ranks rank;
	var &score;
run;

%if &log %then
	%put KS: Computing the CDF for each level of the score variable...;
%* Note that the input dataset is already sorted by &by &target, when computing the number
%* of observations for each by variable and target value;
%if &bands %then %do;
	%* Compute the CDFs with PROC LIFETEST (because this gives me the confidence bands)
	%* (note that the values of the SCORE variable need to be non-negative!! 
	%* (because they represent a time)).
	%* (25/11/04) I already verified that PROC LIFETEST computes the empirical distribution,
	%* as wanted;
	proc lifetest data=_KS_data_ outsurv=_KS_cdf_ alpha=%sysevalf(1-&confidence) noprint;
		by &_by_ &by &target;	%* Variable _BY_ is added so that it appears in _KS_cdf_;
		time &score;
	run;
%end;
%else %do;
	%* Compute CDF of the score using the RANK procedure. Note that I compute the CDF first and 
	%* then the Survival function (right here below as 1 - CDF) in order to have a right-continuous
	%* CDF. If I used DESCENDING FRACTION as a PROC RANK option (instead of FRACTION) in order to
	%* compute the survival function directly, I would get a LEFT-continuous CDF when computed as
	%* 1 - survival!;
	proc rank data=_KS_data_ out=_KS_cdf_ fraction;
		by &_by_ &by &target;
		var &score;
		ranks cdf;
	run;
	%* Sort and dedup by the by variables, the score and the target variable in order to compute
	%* the KS (i.e. I need to sort by the score variable by each by variable combination in order
	%* to compute the KS). The dedupping is necessary because there may be many observations
	%* with the same value of the score and only one should be present in the CDF function;
	proc sort data=_KS_cdf_ nodupkey;
		by &_by_ &score &target;
	run;
	%* Compute the survival function used below, to make things compatible when PROC LIFETEST
	%* is used;
	data _KS_cdf_;
		set _KS_cdf_;
		survival = 1 - cdf;
		drop cdf;
	run;
%end;

%* Gains chart for each target value. This is equivalent to the CDF of the score ranks for
%* each target value;
proc sort data=_KS_rank_;
	by &by &target;
run;
%if &bands %then %do;
	proc lifetest data=_KS_rank_ outsurv=_KS_rank_cdf_ alpha=%sysevalf(1-&confidence) noprint;
		by &_by_ &by &target;	%* Variable _BY_ is added so that it appears in _KS_rank_cdf_;
		time rank;
	run;
%end;
%else %do;
	%* Compute CDF of the score rank. Note that I compute the CDF first and then the Survival
	%* function (right here below as 1 - CDF) in order to have a right-continuous CDF. If I used
	%* DESCENDING FRACTION as a PROC RANK option (instead of FRACTION) in order to compute the
	%* survival function directly, I would get a LEFT-continuous CDF when computed as 1 - survival!;
	proc rank data=_KS_rank_ out=_KS_rank_cdf_ fraction;
		by &_by_ &by &target;
		var rank;
		ranks cdf;
	run;
	%* Sort and dedup by the by variables, the score rank and the target variable in order to 
	%* compute the rank KS
	%* (i.e. I need to sort by the score rank variable by each by variable combination in order
	%* to compute the rank KS). The dedupping is necessary because there may be many observations
	%* with the same value of the score rank and only one should be present in the CDF function;
	proc sort data=_KS_rank_cdf_ nodupkey;
		by &_by_ rank &target;
	run;
	%* Compute the survival function used below, to make things compatible when PROC LIFETEST
	%* is used;
	data _KS_rank_cdf_;
		set _KS_rank_cdf_;
		survival = 1 - cdf;
		drop cdf;
	run;

	%************* Computation of the initialization values of CDF1 and CDF2 *********************;
	data _KS_cdf_minvalue_(keep=&_by_ &score &target cdf);
		set _KS_cdf_;
		%if %quote(&by) ~= %then %do;
			by &_by_;
		%end;
		cdf = 1 - survival;
		%if %quote(&by) ~= %then %do;
			retain firstby_prev 0;
			if first.&_by_ or firstby_prev then output;
			firstby_prev = first.&_by_;
			drop firstby_prev;
		%end;
		%else %do;
			if _N_ in (1, 2) then output;
		%end;
	run;
	proc transpose data=_KS_cdf_minvalue_ out=_KS_cdf_minvalue_value_(drop=_NAME_) prefix=value;
		%if %quote(&by) ~= %then %do;
		by &_by_;
		%end;
		var &target;
	run;
	proc transpose data=_KS_cdf_minvalue_ out=_KS_cdf_minvalue_cdf_(drop=_NAME_) prefix=cdf_min;
		%if %quote(&by) ~= %then %do;
		by &_by_;
		%end;
		var cdf;
	run;
	proc transpose data=_KS_cdf_minvalue_ out=_KS_cdf_minvalue_score_(drop=_NAME_) prefix=score;
		%if %quote(&by) ~= %then %do;
		by &_by_;
		%end;
		var &score;
	run;
	data _KS_cdf_minvalue_;
		merge _KS_cdf_minvalue_value_ _KS_cdf_minvalue_cdf_ _KS_cdf_minvalue_score_;
		%if %quote(&by) ~= %then %do;
		by &_by_;
		%end;
		if ~(value1 ~= value2 and score1 = score2) then do;
			cdf_min1 = 0;
			cdf_min2 = 0;
		end;
	run;
	/*
	proc print data=_KS_cdf_minvalue_; run;
	data _KS_temp_;
		%if %quote(&by) ~= %then %do;
		merge 	_KS_cdf_ end=lastobs
				_KS_cdf_minvalue_;
		by &_by_;
		if first.&_by_ then do;
			cdf1_ret = cdf_min1;
			cdf2_ret = cdf_min2;
		end;
		%end;
		%else %do;
		set _KS_cdf_ end=lastobs;
		if _N_ = 1 then do;
			set _KS_cdf_minvalue_;
			cdf1_ret = cdf_min1;
			cdf2_ret = cdf_min2;
		end;
		%end;
		if lastobs then put _N_=;
	run;
	proc print data=_KS_temp_(obs=10); run;
	*/
	%*********************************************************************************************;
%end;

/*---------------------------- KS based on the SCORE (START) --------------------------------*/
%* Compute the KS and the value of the score at which it occurs;
%if &log %then
	%put KS: Computing KS...;
data _KS_cdf_ _KS_ks_(keep=&_by_ &by at KS KSSgn);
	%if &bands %then %do;
	set _KS_cdf_(where=(&target=&value1))
		_KS_cdf_(where=(&target=&value2) in=in2) end=lastobs;
	by &_by_ &score;	%* Variable &score in the BY statement is used to sort the observations
						%* by &score, regardless of which of the 2 CDFs the score comes from.
						%* This is necessary to compute the KS, i.e. the maximum separation between
						%* the 2 CDFs;
	%end;
	%else %do;
		%if %quote(&by) ~= %then %do;
		merge 	_KS_cdf_ end=lastobs
				_KS_cdf_minvalue_;
		by &_by_;
		%end;
		%else %do;
		set _KS_cdf_ end=lastobs;
		if _N_ = 1 then set _KS_cdf_minvalue_;
		%end;
	%end;

	retain cdf1_ret;	%* Retained value of CDF1, used to compute the KS;
	retain cdf2_ret;	%* Retained value of CDF2, used to compute the KS;
	retain diff 0;		%* Separation between the CDFs;
	retain KS 0;		%* KS;
	retain KSSgn 0;		%* KS with sign (CDF2 w.r.t CDF1);
	retain at 0;		%* Position of the KS;
	retain &score._prev;	%* Previous value of the SCORE variable (necessary when the score variable is discrete);
	retain &score.1_prev;	%* Variable that stores the previous value of the score for &target = &value1;
	retain &score.2_prev;	%* Variable that stores the previous value of the score for &target = &value2;
	retain added 0;		%* Flag to state whether the observation was artificially added (for plotting
						%* purposes) or not;

	%if %quote(&by) ~= %then %do;
	if first.&_by_ then do;
		%if &bands %then %do;
		cdf1_ret = 0;
		cdf2_ret = 0;
		%end;
		%else %do;
		cdf1_ret = cdf_min1;	%* This value comes from _KS_cdf_minvalue_;
		cdf2_ret = cdf_min2;	%* This value comes from _KS_cdf_minvalue_;
		%end;
		diff = 0;
		KS = 0;
		KSSgn = 0;
		at = 0;
		added = 0;
	end;
	%end;
	%else %do;
	if _N_ = 1 then do;
		%if &bands %then %do;
		cdf1_ret = 0;
		cdf2_ret = 0;
		%end;
		%else %do;
		cdf1_ret = cdf_min1;	%* This value comes from _KS_cdf_minvalue_;
		cdf2_ret = cdf_min2;	%* This value comes from _KS_cdf_minvalue_;
		%end;
	end;
	%end;

	cdf = 1 - survival;
	%if &bands %then %do;
	cdf_lcl = 1 - sdf_ucl;	%* Note the inversion of LCL with UCL;
	cdf_ucl = 1 - sdf_lcl;	%* Note the inversion of UCL with LCL;
	%end;
	if &target = &value1 then do;
		%* CDF for first (smaller) target value;
		cdf1 = cdf;
		%if &bands %then %do;
		cdf_lcl1 = cdf_lcl;
		cdf_ucl1 = cdf_ucl;
		%end;
		%* Retained value of the CDF used to compute the KS;
		cdf1_ret = cdf1;
	end;
	else do;	%* Note that missing values of &target were already eliminated at the beginning;
		%* CDF for second (larger) target value;
		cdf2 = cdf;
		%if &bands %then %do;
		cdf_lcl2 = cdf_lcl;
		cdf_ucl2 = cdf_ucl;
		%end;
		%* Retained value of the CDF used to compute the KS;
		cdf2_ret = cdf2;
	end;
/*	if in2 then */	/* Commented out on 16/2/05, because I think that DIFF should be updated
					with every change of ANY of the CDFs, as opposed to the comment that is
					written just below. */
		diff = cdf2_ret - cdf1_ret;
		%** Note that DIFF is updated only when an observation from the second dataset has been read,
		%** because this guarantees that both CDFs are updated at the current record;
	%* 1-23/08/05: Added to include the case when the analysis variable is discrete (which happens
	%* for example when the variable is the score resulting from a decision tree model);
	%* Note the use of function LAG instead of function LAG2 to store the values of the previous 2
	%* records. This is because the value lagged values are computed BEFORE the update of the
	%* variables KS, KSSGN and AT. Therefore, the LAG function retrieves the previous value of 
	%* the variables PRIOR to their update;
	KS_lag2 = lag(KS);
	KSSgn_lag2 = lag(KSSgn);
	at_lag2 = lag(at);
	if &score._prev = &score then do;
		%* This means that the KS computed at the previous iteration is not valid;
		KS = KS_lag2;
		KSSgn = KSSgn_lag2;
		at = at_lag2;
	end;
	%* 2-23/08/05;
	if abs(diff) > KS then do;
		KS = abs(diff);
		KSSgn = diff;
		at = &score;
	end;

	%* Keep previous value of the score (in general and for each target value).
	%* The previous values for each target value are used below (under IF LASTOBS) in order to 
	%* decide whether it is necessary to add a record for each target value with CDF = &max, 
	%* so that the plot of the CDF reaches the maximum possible value of the score;
	&score._prev = &score;
	if &target = &value1 then
		&score.1_prev = &score;
	if &target = &value2 then
		&score.2_prev = &score;

	output _KS_cdf_;

	%if %quote(&by) ~= %then %do;
	if last.&_by_ then do;
	%end;
	%else %do;
	if lastobs then do;
	%end;
		%*** Add the max possible value of the score to the CDF (the max value of the score is given
		%*** in parameter MAX=) so that the CDF plot reaches the maximum value.
		%*** This, of course, is only done if the maximum value passed in MAX= is greater than
		%*** the current score;
		%* For &value1;
		if &max > &score.1_prev then do;
			cdf = 1;
			%if &bands %then %do;
			cdf_lcl = 1;
			cdf_ucl = 1;
			%end;
			&target = &value1;
			&score = &max;
			cdf1 = 1;
			%if &bands %then %do;
			cdf_lcl1 = 1;
			cdf_ucl1 = 1;
			%end;
			%* Set to missing the information regarding the CDF for &value2 (this is necessary)
			%* because if the last observation comes from &target = &value2, the information
			%* regarding the CDF for &value2 will be nonmissing and we do not want this because
			%* there will be one extra point and line in the final plot;
			cdf2 = .;
			%if &bands %then %do;
			cdf_lcl2 = .;
			cdf_ucl2 = .;
			%end;
			%* Flag stating that this observation was added artificially. This is used when
			%* creating the output dataset &out, in order to delete it from the final output dataset
			%* (see more information below when the output dataset &out is created);
			added = 1;
			output _KS_cdf_;
		end;
		%* For &value2;
		if &max > &score.2_prev then do;
			cdf = 1;
			%if &bands %then %do;
			cdf_lcl = 1;
			cdf_ucl = 1;
			%end;
			&target = &value2;
			&score = &max;
			%* Set to missing the information regarding the CDF for &value1 (this is necessary)
			%* because if the last observation comes from &target = &value1, the information
			%* regarding the CDF for &value1 will be nonmissing and we do not want this because
			%* there will be one extra point and line in the final plot;
			cdf1 = .;
			%if &bands %then %do;
			cdf_lcl1 = .;
			cdf_ucl1 = .;
			%end;
			cdf2 = 1;
			%if &bands %then %do;
			cdf_lcl2 = 1;
			cdf_ucl2 = 1;
			%end;
			%* Flag stating that this observation was added artificially. This is used when
			%* creating the output dataset &out in order to delete it from the final output dataset;
			%* (see more information below when the output dataset &out is created);
			added = 1;
			output _KS_cdf_;
		end;

		%* Output to the dataset containing the KS;
		output _KS_ks_;
	end;
	drop survival &score._prev &score.1_prev &score.2_prev KS_lag2 KSSgn_lag2 at_lag2;
	%if &bands %then %do;
	drop _censor_ sdf_lcl sdf_ucl;
	%end;
run;

%* Compute the CDF condifence intervals based on the Kolmogorov Statistic quantiles,
%* taken from the book by Conover;
%* Sort back the _KS_cdf_ by by variables and &target;
proc sort data=_KS_cdf_;
	by &by &target;
run;
data _KS_cdf_;
	merge _KS_cdf_ _KS_KolmogorovBandWidths_(where=(confidence=&confidence)) end=lastobs;
	by &by &target;
	cdf_lclWide = max(0, cdf - width);
	cdf_uclWide = min(1, cdf + width);
	if &target = &value1 then do;
		cdf_lcl1Wide = cdf_lclWide;
		cdf_ucl1Wide = cdf_uclWide;
	end;
	else do;	%* Note that missing values of &target were already eliminated at the beginning;
		cdf_lcl2Wide = cdf_lclWide;
		cdf_ucl2Wide = cdf_uclWide;
	end;
	%* Add the confidence band for the maximum possible score;
	if lastobs and &max > &score then do;
		cdf_lcl1Wide = 1;
		cdf_ucl1Wide = 1;
		cdf_lcl2Wide = 1;
		cdf_ucl2Wide = 1;
	end;
run;

%* Find percentile of the score at which the KS occurs;
%if &log %then
	%put KS: Computing percentile of the score variable at which the KS occurs...;
proc sort data=_KS_rank_;
	by &by &_descending_ &score;
run;
data _KS_ks_(keep=&_by_ &by n KS KSSgn rank &score);
	format &by n KS KSSgn rank &score;
	%* Variables coming in _KS_rank_ are &by, &target, &score and RANK;
	%* Variables coming in _KS_ks_ are &by, KS and AT;
	%if %quote(&by) ~= %then %do;
	merge _KS_rank_ _KS_ks_ _KS_popsize_(keep=&by n);
	by &by;
	%end;
	%else %do;
	set _KS_rank_;
	by &_descending_ &score;
	if _N_ = 1 then do;
		set _KS_ks_;
		set _KS_popsize_(keep=n);
	end;
	%end;
	format KS KSSgn rank percent7.2;
	if at = 0 then do;
		if &score = at then output;
	end;
	else if abs((&score - at) / at) < 1e-4 then output;
run;

%if %quote(&by) ~= %then %do;
	proc sort data=_KS_ks_ nodupkey;
		by &by;
	run;
%end;
%else %do;
	%* Keep the first observation in case there were multiple matches from the condition
	%* abs((&score - at) / at) < 1e-4 above. This may happen when the difference accepted
	%* between variable &score and variable AT is not tight enough. But I cannot do it very
	%* tight at the same time, because it may be too tight and it may happen that no match is
	%* detected.
	%* Note that keeping the first obs assures that the match with the largest score is used
	%* as the position of the KS;
	data _KS_ks_;
		set _KS_ks_(obs=1);
	run;
%end;
/*---------------------------- KS based on the SCORE (END) ----------------------------------*/


/*-------------------------- KS based on the SCORE RANK (START) -----------------------------*/
data _KS_rank_cdf_ _KS_rank_ks_(keep=&_by_ &by at KS KSSgn);
	set _KS_rank_cdf_(where=(&target=&value1))
		_KS_rank_cdf_(where=(&target=&value2) in=in2) end=lastobs;
	by &_by_ rank;
	format cdf1 cdf2 percent7.;
	format KS KSSgn at rank percent7.1;

	retain cdf1_ret 0;	%* Retained value of CDF1, used to compute the KS;
	retain cdf2_ret 0;	%* Retained value of CDF2, used to compute the KS;
	retain diff 0;		%* Separation between the CDFs;
	retain KS 0;		%* KS;
	retain KSSgn 0;		%* KS with sign (CDF2 w.r.t. CDF1);
	retain at 0;		%* Position of the KS;
	retain rank_prev;	%* Previous value of the rank variable (necessary when the score variable is discrete);

	%if %quote(&by) ~= %then %do;
	if first.&_by_ then do;
		cdf1_ret = 0;
		cdf2_ret = 0;
		diff = 0;
		KS = 0;
		KSSgn = 0;
		at = 0;
	end;
	%end;

	cdf = 1 - survival;
	%if &bands %then %do;
	cdf_lcl = 1 - sdf_ucl;	%* Note the inversion of LCL with UCL;
	cdf_ucl = 1 - sdf_lcl;	%* Note the inversion of UCL with LCL;
	%end;
	if &target = &value1 then do;
		%* CDF for first target value;
		cdf1 = cdf;
		%if &bands %then %do;
		cdf_lcl1 = cdf_lcl;
		cdf_ucl1 = cdf_ucl;
		%end;
		%* Retained value of the CDF used to compute the KS;
		cdf1_ret = cdf1;
	end;
	else do;	%* Note that missing values of &target were already eliminated at the beginning;
		%* CDF for second target value;
		cdf2 = cdf;
		%if &bands %then %do;
		cdf_lcl2 = cdf_lcl;
		cdf_ucl2 = cdf_ucl;
		%end;
		%* Retained value of the CDF used to compute the KS;
		cdf2_ret = cdf2;
	end;
/*	if in2 then */ /* Commented out on 16/2/05, because I think that DIFF should be updated
					with every change of ANY of the CDFs, as opposed to the comment that is
					written just below. */
		diff = cdf2_ret - cdf1_ret;
		%** Note that DIFF is updated only when an observation from the second dataset has been read,
		%** because this guarantees that both CDFs are updated at the current record;
	%* 1-23/08/05: Added to include the case when the analysis variable is discrete (which happens
	%* for example when the variable is the score resulting from a decision tree model);
	%* Note the use of function LAG instead of function LAG2 to store the values of the previous 2
	%* records. This is because the value lagged values are computed BEFORE the update of the
	%* variables KS, KSSGN and AT. Therefore, the LAG function retrieves the previous value of 
	%* the variables PRIOR to their update;
	KS_lag2 = lag(KS);
	KSSgn_lag2 = lag(KSSgn);
	at_lag2 = lag(at);
	if rank_prev = rank then do;
		%* This means that the KS computed at the previous iteration is not valid;
		KS = KS_lag2;
		KSSgn = KSSgn_lag2;
		at = at_lag2;
	end;
	%* 2-23/08/05;
	if abs(diff) > KS then do;
		KS = abs(diff);
		KSSgn = diff;
		at = rank;
	end;
	%* Previous value of the score rank;
	rank_prev = rank;

	output _KS_rank_cdf_;

	%* Output to the dataset containing the KS and generate macro variables containing the KS;
	%if %quote(&by) ~= %then %do;
	if last.&_by_ then output _KS_rank_ks_;
	%end;
	%else %do;
	if lastobs then output _KS_rank_ks_;
	%end;
	drop survival rank_prev KS_lag2 KSSgn_lag2 at_lag2;
	%if &bands %then %do;
	drop _censor_ sdf_lcl sdf_ucl;
	%end;
run;

%* Compute the CDF condifence intervals based on the Kolmogorov Statistic quantiles,
%* taken from the book by Conover (they are wider than the CIs given by PROC LIFETEST)
%* Sort back the _KS_cdf_ by by variables and &target;
proc sort data=_KS_rank_cdf_;
	by &by &target;
run;
data _KS_rank_cdf_;
	merge _KS_rank_cdf_ _KS_KolmogorovBandWidths_(where=(confidence=&confidence)) end=lastobs;
	by &by &target;
	cdf_lclWide = max(0, cdf - width);
	cdf_uclWide = min(1, cdf + width);
	if &target = &value1 then do;
		cdf_lcl1Wide = cdf_lclWide;
		cdf_ucl1Wide = cdf_uclWide;
	end;
	else do;	%* Note that missing values of &target were already eliminated at the beginning;
		cdf_lcl2Wide = cdf_lclWide;
		cdf_ucl2Wide = cdf_uclWide;
	end;
run;

%* Add the information on the population size;
data _KS_rank_ks_;
	format &by n;
	%if %quote(&by) ~= %then %do;
	merge _KS_rank_ks_ _KS_popsize_(keep=&by n);
	by &by;
	%end;
	%else %do;
	set _KS_rank_ks_;
	if _N_ = 1 then set _KS_popsize_(keep=n);
	%end;
run;
/*-------------------------- KS based on the SCORE RANK (END) -------------------------------*/

/*------------------------------ OUTPUT DATASETS (START) ------------------------------------*/
%* Dataset for KS;
%if %quote(&outks) ~= %then %do;
	%let outks_name = %scan(&outks, 1, '(');
	data &outks;
		format &by type;
		set _KS_ks_(in=in1) _KS_rank_ks_(in=in2 rename=(at=rank));
		&byst;
		format type $32.;
		if in1 then
			type = "Score Based";
		else if in2 then
			type = "Rank-Score Based";
		label type = "Type of KS";
		label n = " ";
		%if %quote(&by) ~= %then %do;
		drop &_by_;
		%end;
	run;
	%if &log %then %do;
		%put;
		%put KS: Dataset %upcase(&outks_name) created with the KS and RANK KS values.;
	%end;
%end;
%else %do;
	title2 "%nrbquote(Dataset %upcase(&data))";
	title3 "Target=%upcase(&target), Score=%upcase(&score)";
	title4 "KS (based on the score)";
	%* Set labels option so that the labels are shown as the column titles in the PROC PRINT;
	proc print data=_KS_ks_ noobs;
		var &by n KS KSSgn rank &score;
	run;
	title2 "%nrbquote(Dataset %upcase(&data))";
	title3 "Target=%upcase(&target), Score=%upcase(&score)";
	title4 "RANK KS (based on the score rank)";
	%* Set labels option so that the labels are shown as the column titles in the PROC PRINT;
	proc print data=_KS_rank_ks_(rename=(at=rank)) noobs;
		var &by n KS KSSgn rank;
	run;
	title4;
	title3;
	title2;
%end;

%if %quote(&out) ~= %then %do;
	%let out_name = %scan(&out, 1, '(');
	proc sort data=_KS_cdf_;
		by &by &target &score;
	run;
	proc sort data=_KS_rank_cdf_;
		by &by &target rank;
	run;
	data &out;
		set 	_KS_cdf_ (keep=&by &target &score cdf
						  	   /* For CI given by PROC LIFETEST (thinner) */
							   %if &bands %then %do;
						  	   cdf_lcl cdf_ucl
							   %end;
						  	   /* For CI computed by me based on Conover (wider) */
							   %else %do;
						  	   cdf_lclWide cdf_uclWide
							   %end;
							   added
						  rename=(cdf=CDF
						  		  /* For CI given by PROC LIFETEST (thinner) */
								  %if &bands %then %do;
						  		  cdf_lcl=CDFLower%sysevalf(&confidence*100)
								  cdf_ucl=CDFUpper%sysevalf(&confidence*100)
								  %end;
								  /* For CI computed by me based on Conover (wider) */	
								  %else %do;
								  cdf_lclWide=CDFLower%sysevalf(&confidence*100)
								  cdf_uclWide=CDFUpper%sysevalf(&confidence*100)
								  %end;));
		by &by &target;
		if ~last.&target or ~added;
		%** The above IF is to not read the last observation in _KS_cdf_ by &target value
		%** because those observations were added by me so that the CDF is also computed
		%** for the maximum possible value of the score (the CDF is equal to 1 for this value
		%** by the way), so that a graph covering all the score range is produced.
		%** But the addition of these 2 observations creates the dataset _KS_cdf_ with one
		%** more observation by &target value than the dataset _KS_rank_cdf_, which, 
		%** doing the SET I do here (i.e. a separate SET for each dataset (the second SET is below)
		%** produces an
		%** &out dataset where the last 2 observations of the dataset _KS_cdf_ are not read,
		%** which is not what we want because the last 2 observations correspond to the
		%** higher &target value.
		%** Thus, by doing %if ~last.&target, the 2 observations artificially added by me
		%** are removed;
		set		_KS_rank_cdf_(keep=&by &target rank cdf
						  	  	   /* For CI given by PROC LIFETEST (thinner) */
								   %if &bands %then %do;
							  	   cdf_lcl cdf_ucl
								   %end;
						  	  	   /* For CI computed by me based on Conover (wider) */
								   %else %do;
							  	   cdf_lclWide cdf_uclWide
								   %end;
							  rename=(cdf=RankCDF
						  		  	  /* For CI given by PROC LIFETEST (thinner) */
									  %if &bands %then %do;
									  cdf_lcl=RankCDFLower%sysevalf(&confidence*100)
									  cdf_ucl=RankCDFUpper%sysevalf(&confidence*100)
									  %end;
								  	  /* For CI computed by me based on Conover (wider) */
								  	  %else %do;
									  cdf_lclWide=RankCDFLower%sysevalf(&confidence*100)
									  cdf_uclWide=RankCDFUpper%sysevalf(&confidence*100)
									  %end;));
		label 	&target = "Target Variable (&target)"
				&score 	= "Score (&score)"
				CDF 	= "Cumulative Distribution Function of the Score (&score)"
				CDFLower%sysevalf(&confidence*100) = "Lower end of the %sysevalf(&confidence*100)% CDF Confidence Band"
				CDFUpper%sysevalf(&confidence*100) = "Upper end of the %sysevalf(&confidence*100)% CDF Confidence Band"
				rank 	= "Score Rank"
				RankCDF = "Cumulative Distribution Function of the Score Rank"
				RankCDFLower%sysevalf(&confidence*100) = "Lower end of the %sysevalf(&confidence*100)% Rank CDF Confidence Band"
				RankCDFUpper%sysevalf(&confidence*100) = "Upper end of the %sysevalf(&confidence*100)% Rank CDF Confidence Band";
		drop added;
	run;
	%if &log %then %do;
		%if %quote(&outks) = %then
			%put;
		%put KS: Dataset %upcase(&out_name) created, with the data necessary to produce the distribution plots.;
	%end;
%end;
/*------------------------------ OUTPUT DATASETS (END) --------------------------------------*/


/*------------------------------------ CDF PLOTS --------------------------------------------*/
%if &plot %then %do;
	%if &log %then %do;
		%put;
		%if %quote(&by) ~= %then
			%put KS: Plotting the CDF for each by variable combination and each level of the score variable...;
		%else
			%put KS: Plotting the CDF for each level of the score variable...;
	%end;

	/*-------------------------------- Annotate datasets ------------------------------------*/
	%* Define annotate dataset to show the position of the KS based on the score;
	data _KS_anno_;
		format &by x y xsys ysys position text;
		set _KS_ks_;
		length text $50;
		retain xsys "2";		%* Data values;
		retain ysys "1";		%* Percentage of data area;
		retain position "3";	%* One cell above, left aligned;
		x = &score;
		y = 10; text = "KS=" || trim(left(put(ks, percent7.1))); 		output;
		y = 5; 	text = "rank=" || trim(left(put(rank, percent7.1))); 	output;
		y = 0; 	text = "&score=" || trim(left(put(&score, 6.4))); 		output;
		drop KS rank &score;
	run;
	%* Define annotate dataset to show the position of the KS based on the score rank;
	data _KS_rank_anno_;
		format &by x y xsys ysys position text;
		set _KS_rank_ks_;
		length text $50;
		retain xsys "2";		%* Data values;
		retain ysys "1";		%* Percentage of data area;
		retain position "3";	%* One cell above, left aligned;
		x = at;
		y = 10; text = "KS=" || trim(left(put(ks, percent7.1))); 	output;
		y = 5; 	text = "rank=" || trim(left(put(at, percent7.1))); 	output;
		drop KS at;
	run;
	/*---------------------------------------------------------------------------------------*/

	/*---------------------------------- Plot settings --------------------------------------*/
	%DefineSymbols;
	%* Colors;
	%let color1 = blue;
	%let color2 = red;
	%if %quote(&color) ~= %then %do;
		%let color1 = %scan(&color, 1, ' ');
		%let color2 = %scan(&color, 2, ' ');
	%end;
	%* Symbols;
	symbol1 %if ~&points %then value=none; %else value=dot; line=1 width=2 interpol=join color=&color1;
	symbol2 %if ~&points %then value=none; %else value=dot; line=1 width=2 interpol=join color=&color2;
	symbol3 value=none interpol=join line=2 width=1 color=&color1;
	symbol4 value=none interpol=join line=2 width=1 color=&color2;
	%* Labels for legend (I use the TRANWRD function to replace the double quotes by single
	%* quotes so that there is no error in the LEGEND statement below when the group variable
	%* is a character variable. Note that I use the STR function instead of QUOTE to mask
	%* the double and single quotes so that the function is resolved at execution not at
	%* compilation. If I use the QUOTE function, there is an error because the macro compiler
	%* assumes that at the position of the quotes there are really quotes present);
	%let label1 = %upcase(&target)=%sysfunc(tranwrd(&value1, %str(%"), %str(%')));
	%let label2 = %upcase(&target)=%sysfunc(tranwrd(&value2, %str(%"), %str(%')));
	%if %quote(&label) ~= %then %do;
		%let label1 = %scan(&label, 1, ' ');
		%let label2 = %scan(&label, 2, ' ');
	%end;
	/*---------------------------------------------------------------------------------------*/

	/*---------------------------------- CDF for SCORE --------------------------------------*/
	title "%nrbquote(KS for dataset %upcase(&data))" justify=center 
		  "based on target variable %upcase(&target) and score variable %upcase(&score)";
	%* Axis;
	axis1 order=(%SetAxis(&min, &max, 10)) label=("Score");
	axis2 label=(angle=90 "Cumulative Distribution Function");
	%* Legend;
	legend1 label=("Group")
			value=(tick=1 "&label1" tick=4 "&label2"
				   tick=2 "%sysevalf(&confidence*100)% Lower/Upper Bound"
				   tick=3 "%sysevalf(&confidence*100)% Lower/Upper Bound"
				   tick=5 "%sysevalf(&confidence*100)% Lower/Upper Bound"
				   tick=6 "%sysevalf(&confidence*100)% Lower/Upper Bound");
		%** Note: The tick= option in the legend statement defines which legend entry the 
		%** text entry refers to;
	%* Create the plot string used in the plot statement of the GPLOT;
		/* To plot CI given by PROC LIFETEST (thinner) */
	%if &bands %then %do;
		%let plotstr = 	cdf1*&score=1 cdf_lcl1*&score=3 cdf_ucl1*&score=3
				 		cdf2*&score=2 cdf_lcl2*&score=4 cdf_ucl2*&score=4;
	%end;
		/* To plot CI computed by me based on Conover (wider) */
	%else %do;
		%let plotstr = 	cdf1*&score=1 cdf_lcl1Wide*&score=3 cdf_ucl1Wide*&score=3
				 		cdf2*&score=2 cdf_lcl2Wide*&score=4 cdf_ucl2Wide*&score=4;
	%end;
	%if %quote(&by) ~= %then %do;
		%do i = 1 %to &nro_groups;
			%* Subset the annotate dataset to each by group;
			data _KS_anno_i_;
				set _KS_anno_;
				by &_by_;
				where &_by_ = &i;
				%* Create the macro variable AT that is used in the HREF= option of the plot statement;
				if last.&_by_ then
					call symput ('at', x);
			run;

			%* Create title2 showing each by variable combination;
			proc transpose data=_KS_anno_i_(obs=1) name=var out=_KS_byvalues_(rename=(col1=value));
				var &by;
			run;
			%let byvalues = %MakeListFromVar(_KS_byvalues_, var=value, log=0);
			%CreateInteractions(&by, with=&byvalues, join==, allInteractions=0, macrovar=title2_global, log=0);
			%let title2 = &title2_global;
			%symdel title2_global; quit;	%* Delete global macro variable created in %CreateInteractions;
			%let title2 = %MakeList(%quote(&title2), sep=%quote(,));
			%** The QUOTE function is necessary above because &title2 contains equal signs and
			%** they are interpreted as parameter names of the macro MakeList if the quote function
			%** is not used;
			%* Do the PLOT;
			title2 "&title2";
			proc gplot data=_KS_cdf_(where=(&_by_=&i)) annotate=_KS_anno_i_;
				plot &plotstr / overlay legend=legend1 haxis=axis1 vaxis=axis2
			  					href=&at chref=green grid;
			run;
			quit;
		%end;
	%end;
	%else %do;	
		%* Create the macro variable AT that is used in the HREF= option of the plot statement;
		data _NULL_;
			set _KS_anno_ end=lastobs;
			if lastobs then
				call symput ('at', x);
		run;
		proc gplot data=_KS_cdf_ annotate=_KS_anno_;
			plot &plotstr / overlay legend=legend1 haxis=axis1 vaxis=axis2
			   				href=&at chref=green grid;
		run;
		quit;
	%end;
	title;

	/*----------------------------- CDF for SCORE RANK --------------------------------------*/
	title "%nrbquote(RANK KS for dataset %upcase(&data))" justify=center 
		  "based on target variable %upcase(&target) and the score rank of %upcase(&score)";
	%* Symbol for naive line;
	symbol5 color=black value=none line=2 interpol=join;
	%* Axis;
	axis1 order=(0 to 1 by 0.1) label=("Score Rank");
	axis2 label=(angle=90 "%nrstr(%Captured) Response");
	%* Legend;
	legend1 label=("Group")
			value=(tick=1 "&label1" tick=4 "&label2"
				   tick=2 "%sysevalf(&confidence*100)% Lower/Upper Bound"
				   tick=3 "%sysevalf(&confidence*100)% Lower/Upper Bound"
				   tick=5 "%sysevalf(&confidence*100)% Lower/Upper Bound"
				   tick=6 "%sysevalf(&confidence*100)% Lower/Upper Bound"
				   tick=7 "Naive");
		%** Note: The tick= option in the legend statement defines which legend entry the 
		%** text entry refers to;

	%* Create the plot string used in the plot statement of the GPLOT;
		/* To plot CI given by PROC LIFETEST (thinner) */
	%if &bands %then %do;
		%let plotstr = 	cdf1*rank=1 cdf_lcl1*rank=3 cdf_ucl1*rank=3
				 		cdf2*rank=2 cdf_lcl2*rank=4 cdf_ucl2*rank=4
				 		rank*rank=5;
	%end;
		/* To plot CI computed by me based on Conover (wider) */
	%else %do;
		%let plotstr = 	cdf1*rank=1 cdf_lcl1Wide*rank=3 cdf_ucl1Wide*rank=3
				 		cdf2*rank=2 cdf_lcl2Wide*rank=4 cdf_ucl2Wide*rank=4
				 		rank*rank=5;
	%end;
	%if %quote(&by) ~= %then %do;
		%do i = 1 %to &nro_groups;
			%* Subset the annotate dataset to each by group;
			data _KS_rank_anno_i_;
				set _KS_rank_anno_;
				by &_by_;
				where &_by_ = &i;
				%* Create the macro variable AT that is used in the HREF= option of the plot statement;
				if last.&_by_ then
					call symput ('at', x);
			run;

			%* Create title2 showing each by variable combination;
			proc transpose data=_KS_rank_anno_i_(obs=1) name=var out=_KS_byvalues_(rename=(col1=value));
				var &by;
			run;
			%let byvalues = %MakeListFromVar(_KS_byvalues_, var=value, log=0);
			%CreateInteractions(&by, with=&byvalues, join==, allInteractions=0, macrovar=title2_global, log=0);
			%let title2 = &title2_global;
			%symdel title2_global; quit;	%* Delete global macro variable created in %CreateInteractions;
			%let title2 = %MakeList(%quote(&title2), sep=%quote(,));
			%** The QUOTE function is necessary above because &title2 contains equal signs and
			%** they are interpreted as parameter names of the macro MakeList if the quote function
			%** is not used;

			%* Do the PLOT;
			title2 "&title2";
			proc gplot data=_KS_rank_cdf_(where=(&_by_=&i)) annotate=_KS_rank_anno_i_;
				plot &plotstr / overlay legend=legend1 haxis=axis1 vaxis=axis2
			  					href=&at chref=green grid;
			run;
			quit;
		%end;
	%end;
	%else %do;	
		%* Create the macro variable AT that is used in the HREF= option of the plot statement;
		data _NULL_;
			set _KS_rank_anno_ end=lastobs;
			if lastobs then
				call symput ('at', x);
		run;
		proc gplot data=_KS_rank_cdf_ annotate=_KS_rank_anno_;
			plot &plotstr / overlay legend=legend1 haxis=axis1 vaxis=axis2
			   				href=&at chref=green grid;
		run;
		quit;
	%end;
	title;

	%DefineSymbols;
%end;
%end;	%* if ~&error;

proc datasets nolist;
	delete 	_KS_anno_
			_KS_anno_i_
			_KS_byvalues_
			_KS_cdf_
			_KS_cdf_minvalue_
			_KS_cdf_minvalue_cdf_
			_KS_cdf_minvalue_score_
			_KS_cdf_minvalue_value_
			_KS_data_
			_KS_freq_
			_KS_ks_
			_KS_KolmogorovBandWidths_
			_KS_n_
			_KS_popsize_
			_KS_rank_
			_KS_rank_anno_
			_KS_rank_anno_i_
			_KS_rank_cdf_
			_KS_rank_ks_;
quit;

%if &log %then %do;
	%put;
	%put KS: Macro ends;
	%put;
%end;

%ResetSASOptions;
%end;	%* if ~%CheckInputParameters;
%MEND KS;


/* (8/5/05)
Tests para el correcto funcionamiento del calculo del KS cuando el valor minimo (e.g. el 0)
de la variable se repite varias veces y la target variable toma ambos valores para ese valor.
El codigo fue tomado de un Untitled cuando estaba calculando el Gini y el KS de las variables
presentes en el modelo por Quarter, en el codigo 03-Results\code\sensibilidad-ksvar-time2.sas.
Para hacer estas pruebas tengo que eliminar el PROC DATASETS DELETE del final de la macro %KS.

El calculo del KS en terminos del score (as opposed to en terminos del score rank) da en
general bien, pero no siempre. Para la variable B_AGE_ABI_MIN_L de POPDATA = CBCC obtengo
un 72.4% con mi macro comparado con el 9.5% verdaderos calculados por NPAR1WAY.

* Esto muestra el KS de 9.5%;
proc npar1way data=cbcc_data EDF;
	where B_AGE_ABI_MIN_L ~= &miss;
	class &target_orig;
	var B_AGE_ABI_MIN_L;
run;

data cbcc_data;
	set cbcc.Ksginiquarter_model_dq90_c12_v4;
run;
%KS(cbcc_data(where=(IG_X_B_UTI_REV_MAX ~= &miss)),
	target=&target_orig,
	score=IG_X_B_UTI_REV_MAX,
	bands=1,
	min=min,
	max=max,
	out=ks1,
	plot=0,
	log=1);
proc npar1way data=cbcc_data EDF;
	where IG_X_B_UTI_REV_MAX ~= &miss; *and ~(IG_X_B_UTI_REV_MAX = 0 and &target_orig = 0);
	class &target_orig;
	var IG_X_B_UTI_REV_MAX;
run;

%KS(cbcc_data(where=(B_AGE_ALL_MIN_L ~= &miss)),
	target=&target_orig,
	score=B_AGE_ALL_MIN_L,
	by=quarter,
	bands=0,
	min=min,
	max=max,
	out=ks,
	plot=0,
	log=1);
proc npar1way data=cbcc_data EDF;
	where B_AGE_ALL_MIN_L ~= &miss; *and ~(B_AGE_ALL_MIN_L = 0 and &target_orig = 0) and quarter = "2003Q1";
	class &target_orig;
	var B_AGE_ALL_MIN_L;
run;

* Rank KS por el SAS;
proc npar1way data=_KS_rank_ EDF;
	class &target_orig;
	var rank;
run;
%sort(_KS_rank_cdf_, by=rank &target_orig);
data _KS_rank_cdf_;
	format rank best12.;
	set _KS_rank_cdf_;
run;
*/
