/* This macro calls the macro 'macro' that gets the parameters 'inparams' and returns the
parameters 'outparams'. The parameter names have to be separated by spaces in both 'inparams'
and 'outparams'.
The variable nin is determined from the variable 'inparams' unless its
value is not 0, 0 being the default value as set here. The variable nin may have to be given
a specific value if the format of the input parameters is such that the number of input
parameters cannot be determined correctly. For ex. if the input parameters have a blank as one of
the parameters (this is because the way the number of parameters is determined is by counting
the number of blanks in the variable 'inparams'). For instance, there will be problems if
'inparams' is equal to 'x sep=%quote( )'. In this case nin would take the value of 3 instead
of 2, as is the correct number of parameters, just because after the equal sign there is a
blank space. This problem actually happens if we call the function MakeList with the variable sep
taking the value of a blank, like in this example.
29/9/04:
Variables sep and sepout are used to specify respectively:
- the separation character used to separate the input parameters passed in inparams
(an acceptable separation parameter for sep is ':')
- the separation character used to distinguish the output parameters generated by the
macro being called with this macro.
Example:
%callmacro(MakeList, x1 x2:prefix=p_:suffix=_s:sep=%quote(,), nin=3, sep=:, sepout=%quote(,));
*/
&rsubmit;
%MACRO callmacro(macro, inparams, outparams, nin=0, sep=%quote( ), sepout=%quote( )) 
		/ store des="Calls a macro and stores the returned values in macro variables";
%local i nin nout out params parname varname;
%local commaIndex head lengthParname tail;
/* Determining the number of input parameters passed to the macro 'macro' and the number
of output parameters returned by it. The function 'compress' eliminates all the blanks in
its argument and the function 'compbl' reduces multiple consecutive blanks into a single one.
Note that the number of input parameters is computed from the 'inparams' variable ONLY when
nin is equal to 0. Otherwise, the number of input parameters is the value of nin passed. */
%if &nin = 0 %then
	%let nin = %eval( %length(%sysfunc(compbl(%quote(&inparams)))) - %length(%sysfunc(compress(%quote(&inparams)))) + 1 ) ;
%let nout = %eval( %length(&outparams) - %length(%sysfunc(compress(&outparams))) + 1 );

/* Creating the list of parameters to pass to the macro 'macro' */
%let params = %scan( %quote(&inparams) , 1 , &sep );	%*** Initializing params with the first in parameter;
%do i = 2 %to &nin;
	%let parname = %scan( %quote(&inparams) , &i , &sep );
	%* This checks whether there is an expression of the type %quote(,) in the value of
	%* one of the parameters, so that the value of the parameter is kept as %quote(,).
	%* e.g. sep=%quote(,), or sep=%quote(a,b), etc;
	%let commaIndex = %index(%quote(&parname),%quote(,));
	%if &commaIndex %then %do;
		%let lengthParname = %length(&parname);
		%let head = %substr(%quote(&parname), 1 , &commaIndex-1);
		%if &lengthParname > &commaIndex %then
			%let tail = %substr(%quote(&parname), &commaIndex+1);
		%let parname = &head%nrstr(%quote)(,)&tail;
	%end;
	%let params = &params , &parname;
%end;

/* Calling the macro */
%let out = %&macro(&params);

/* Creating the list of output parameters returned by the macro 'macro' */
%do i = 1 %to &nout;
	%let varname = %scan( &outparams , &i , ' ' );
	%let &varname = %scan( %quote(&out) , &i , &sepout );
%end;
%MEND callmacro;

