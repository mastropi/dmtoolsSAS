/* MACRO %EvaluationChart
Version: 		3.03
Author: 		Daniel Mastropietro
Created: 		24-Sep-2004
Modified: 		19-Mar-2016 (previous: 03-Aug-2015)
SAS Version:	9.3

DESCRIPTION:
This macro plots an evaluation chart for a scoring model with a categorical target variable
which can be either binary or multilevel.
Available evaluation charts are:
- Lift Chart
- Gains Chart (%Captured Response for each level of the target variable) (only available for
dichotomouse variables)

Optionally, an output dataset with the data necessary to reproduce the evaluation charts is
created. These data include the confidence bands for the Gains Charts.

Keywords used below:
LR = Logistic Regression
DT = Decision Tree

USAGE:
%EvaluationChart(
	data,				*** Input datasets
	target=y,			*** Target variable
	score=p,			*** Score variable(s)
	by=,				*** By variables
	event=1,			*** Event of interest
	model=LR,			*** Model used to generate the score (LR, DT)
	leaf=leaf,			*** Name of variable defining the leaves in a DT
	step=,				*** Percent step to use for the score variable when constructing the plot
	groups=,			*** Nro. of percentile groups to use in plot
	percentiles=,		*** Percentiles to use in plot
	chart=lift,			***	Type of evaluation chart
	plot=1,				*** Make plot of Evaluation Chart?
	overlay=0,			*** Overlay the Evaluation Charts on the same plot?
	best=1,				*** Show the Best Lift/Gains Curve?
	pointlabels=0,		*** Use pointlabels showing quantile size?
	points=1,			*** Show points indicating plotting points?
	legend=1,			*** Show legend in graph?
	bands=0,			*** Show confidence bands for the Gains Chart?
	bandtype=SIMUL,		*** Type of confidence bands to compute, simultaneous or pointwise
	confidence=0.95,	*** Confidence level for the Gains confidence bands
	out=,				*** Output dataset with the data to make the evaluation charts
	outstat=,			*** Output dataset with the KS Statistic and Gini Index
	odsfile=,			*** Quoted name of the file where the Evaluation Chart is saved
	odsfiletype=pdf,	*** Type of the file specified in ODSFILE
	libformat=,			*** Library where the target formats created by the macro are stored
	print=1,			*** Show KS and Gini Index in the output window?
	log=1);				*** Show messages in the log?

REQUIRED PARAMETERS:
- data:			Dataset or list of datasets containing the target and score variables to be used
				in the construction of the Evaluation Chart.
				When multiple datasets are specified, the evaluation chart shows the curves
				for each dataset overlayed on the same graph.
				In addition, it is assumed that the target and score variables have the same name
				are of the same type and can potentially take the same values in all datasets.
				Data options are only allowed when only one dataset is specified.

OPTIONAL PARAMETERS:
- target:		Target variable that is predicted by the model under analysis.
				The type of variable depends on the type of evaluation chart being requested.
				The target variable can be either character or numeric.
				default: y

- score:		Score variable or list of score variables generated by the scoring model to evaluate.
				If a list of variables is given, the final score used for the graph is the sum of the
				given score variables. This is useful in case of multilevel target variables and when
				we want to analyze the performance of the model for a set of levels.
				It is assumed that a higher score implies a higher probability that the
				target variable be equal to the event specified in EVENT=.
				default: p

- by:			List of by variables by which the computation of the evaluation charts is performed.
				If by variables are passed ONLY one dataset is allowed in 'data'.

- event:		Level(s) of the target variable that represent the event of interest in the analysis.
				The values have to be of the same type as the type of the target variable.
				For character values, use SINGLE quotes to enclose their values.
				When more than one value is defined as an event, separate the different values with
				a blank space.
				Ex: EVENT='1-Low' '2-Middle'
				default: 1

- model:		Type of model used to generate the scoring model.
				Possible values: LR (for Logistic Regression), DT or TREE (for Decision Tree)
				When MODEL=DT or TREE, the number of points generated in the evaluation chart
				is given by the number of leaves in the tree.
				default: LR

- leaf:			Name of the variable defining the leaves in a DT.
				Only used when MODEL=DT or MODEL=TREE.
				default: leaf

- step:			Step (in percent) to use for the score variable to make the evaluation chart.
				This is the percentage to be used to group the ordered score values in order
				to compute the number of target events present in each group, which is used
				to construct the evaluation chart.
				This parameter has an effect only when:
				- the model used to generate the scoring model is NOT a Decision Tree.
				(i.e. MODEL ~= DT and MODEL ~= TREE). For DTs the score values are grouped
				by the leaves of the tree.
				However, even if the scoring model is a DT, the number of groups specified
				in this parameter is used to generate the 'Best Curve' in that case, which
				reflects the best possible performance of a model with the data used to create
				the scoring model.
				- parameter 'percentiles' is empty.
				Leave all GROUPS=, STEP=, PERCENTILES= empty if no grouping is wished.
				default: empty

- groups:		Nro. of groups to use for the scoring variable to make the evaluation chart.
				This number defines the step (in %) used for each point in the evaluation chart,
				which is calculated as 100/groups.
				For ex. if GROUPS=20, the step is 5%.
				This parameter has an effect only when:
				- the model used to generate the scoring model is NOT a Decision Tree.
				(i.e. MODEL ~= DT and MODEL ~= TREE). For DTs the groups used to generate
				the evaluation chart are given by the leaves of the tree.
				However, even if the scoring model is a DT, the number of groups specified
				in this parameter is used to generate the 'Best Curve' in that case, which
				reflects the best possible performance of a model with the data used to create
				the scoring model.
				- parameter 'step' and 'percentiles' are both empty.
				Leave all GROUPS=, STEP=, PERCENTILES= empty if no grouping is wished.
				default: empty

- percentiles:	List of percentiles of the scoring variable to use in the evaluation chart.
				If empty, the number of groups passed in 'groups' is used.
				This parameter overrides any value passed in parameter 'groups'.
				Leave all GROUPS=, STEP=, PERCENTILES= empty if no grouping is wished.
				default: empty

- chart:		Type of evaluation chart to be made.
				Possible values:
				- LIFT:  Lift chart for the prediction of the target variable equal to 'event'
				- GAINS: %Captured Response for each level of the target variable
				default: lift

- plot:			Whether to plot the evaluation chart.
				Possible values: 0 => No, 1 => Yes.
				default: 1

- overlay:		Whether to overlay all the evaluation charts on the same plot for comparison purposes.
				Possible values: 0 => No, 1 => Yes.
				default: 0

- best:			Whether to plot the Best Lift/Gains curve.
				Possible values: 0 => No, 1 => Yes.
				default: 1 when the plot corresponds to a single dataset with no BY variables,
				Otherwise the default value is 0. The reason for setting the value to 0 when
				BY variables are passed is because the event rate in each of the dataset may be
				different, making therefore the Best curve (which is based on the WHOLE dataset)
				uninformative. Note that when multiple datasets are passed, there is no best
				curve (unless of course the datasets come from the same original dataset that
				is splitted according to BY variable values... but this case is not taken into
				account).

- pointlabels:	Whether to show point labels in the evaluation chart indicating the number of
				observations falling in each percentile.
				Possible values: 0 => No, 1 => Yes.
				default: 0

- points:		Show points indicating plotting points in the graph?
				Possible values: 0 => No, 1 => Yes.
				default: 0

- legend:		Show legend in graph?
				Possible values: 0 => No, 1 => Yes.
				default: 1

- bands:		Whether to create (in the output dataset) and show the confidence bands for
				the Gains Charts.
				Even if no Gains Charts are requested (because CHART~=GAINS), 4 columns
				for each analyzed dataset containing the confidence bands are created in
				the output dataset.
				Possible values: 0 => No, 1 => Yes.
				default: 0

- bandtype:		Type of confidence bands to compute, whether simultaneous bands or pointwise
				intervals.
				Possible values: POINT (alias POINTWISE), SIMUL (alias SIMULTANEOUS)
				default: SIMUL

- confidence:	Confidence level for the confidence bands.
				Possible values: 0.80, 0.90, 0.95, 0.98, 0.99.
				default: 0.95

- out:			Output dataset containing the data to make all available evaluation charts
				(LIFT, GAINS) for each dataset/model analyzed.
				The output dataset contains the following columns:
				- model: 				Name of the dataset, BY group or model being evaluated.
				- type:					Type of model (specified in the MODEL parameter).
				- <target>:				Value of the event of interest specified in the EVENT parameter.
										(the name of the column is defined by the TARGET parameter)
				- <score>: 				Average value of the score variable for the corresponding quantile.
										(the name of the column is defined by the SCORE parameter)
				- quantile: 			Quantile of the score rank (HORIZONTAL AXIS of Evaluation Chart).
				- Naive: 				Naive 45-degree line corresponding to the Gains using random selection.
				- BestLift: 			Best possible Lift with the data at hand.
				- BestGainsEvent: 		Best possible Event Gains with the data at hand.
				- BestGainsNonEvent: 	Best possible Non-event Gains with the data at hand.
				- LiftLower: 			Lower end of confidence band for the Lift.
				- Lift: 				Data for the Lift Charts (VERTICAL AXIS).
				- LiftUpper: 			Upper end of confidence band for the Lift.
				- GainsEventLower: 		Lower end of confidence band for the Event Gains.
				- GainsEvent: 			Data for the Gains Chart for <target>=<event> (VERTICAL AXIS).
				- GainsEventUpper: 		Upper end of confidence band for the Event Gains.
				- GainsNonEventLower: 	Lower end of confidence band for the Non-Event Gains.
				- GainsNonEvent: 		Data for the Gains Chart for <target>~=<event> (VERTICAL AXIS).
				- GainsNonEventUpper: 	Upper end of confidence band for the Non-Event Gains.
				- hits: 				Nro. of hits (events) in current quantile.
				- n: 					Nro. of observations in current quantile.
				- CumHits: 				Cumulative nro. of hits (events) up to current quantile.
				- CumN: 				Cumulative nro. of obs up to current quantile.
				- TotalHits: 			Total nro. of hits in the dataset.
				- TotalN: 				Total nro. of observations in the dataset.

- outstat:		Output dataset with the KS Statistic and Gini Index. It has the following columns:
				- model: 				Name of the dataset, BY group or model being evaluated.
				- TotalN:				Total number of cases used for the computation of the measures.
				- EventRate:			Event Rate
				- type:					Type of model (specified in the MODEL parameter).
				- KSLower: 				Lower end of the confidence interval for KS.
				- KS: 					Kolmogorov-Smirnov statistic.
				- KSUpper: 				Upper end of the confidence interval for KS.
				- QuantileAtKSLower:	Quantile at which the Lower KS occurs.
				- QuantileAtKS: 		Quantile at which the KS value occurs.
				- QuantileAtKSUpper: 	Quantile at which the Upper KS occurs.
				- GiniLower: 			Lower end of the confidence interval for the Gini Index.
				- Gini: 				Gini Index
				- GiniUpper: 			Upper end of the confidence interval for the Gini Index.

- odsfile:		Quoted name of the file where the Evaluation Chart should be saved in the
				format given by the ODSFILETYPE= parameter.
				
- odsfiletype:	Type of file to be created at the location specified by the ODSFILE= parameter.
				default: pdf

- libformat:	Library where the target formats defined by the macro are stored.
				This is useful when the macro is called from within Enterprise Miner where
				the formats should be stored in the APFMTLIB library in order to be available
				in different nodes, including the Results window of a particular node execution!
				default: WORK

- print:		Whether to show the KS and Gini Index for each dataset analyzed or for each
				by variables combination.
				Possible values: 0 => No, 1 => Yes.
				default: 1

- log:			Show messages in the log?
				Possible values: 0 => No, 1 => Yes.
				default: 1

NOTES:
1.- Together with the evaluation chart for the scoring model being evaluated, the curve
corresponding to the best possible model is also shown (which appears as 'Best' in
the graph).
When more than one dataset is passed for evaluation, the computation of the best curve is based
on the last dataset listed in 'data'. This may not be of concern if, as usually is the case,
all datasets listed for evaluation contain the same data and only differ on the predicted score.

2.- When more than one dataset are passed in DATA=, the following should be noted:
- The target variable should take the same values in all datasets listed, because the best curve
is computed using the target variable stored in the last dataset listed.
- The best curve is computed for the last dataset listed. That is the best curve uses the
percentile groups defined by the last dataset listed.

OTHER MACROS AND MODULES USED IN THIS MACRO:
- %Callmacro
- %CheckInputParameters
- %Colors
- %CreateInteractions
- %ExecTimeStart
- %ExecTimeStop
- %GetDataOptions
- %Getnobs
- %GetNroElements
- %GetVarAttrib
- %GetVarType
- %MakeList
- %MakeListFromName
- %MakeListFromVar
- %RemoveFromList
- %ResetSASOptions
- %SetSASOptions

SEE ALSO:
- %GainsChart (which cals %EvaluationChart with parameter CHART=GAINS)
- %LiftChart (which calls %EvaluationChart with parameter CHART=LIFT)

EXAMPLES:
1.- %EvaluationChart(scoredData, target=DQ, score=p, pointlabels=1, groups=20);
This creates a lift chart for the target variable DQ using the score stored in variable P
in dataset SCOREDDATA. The event of interest used in the scoring model is DQ=1
(since the default for parameter 'event' is 1).
The model is assumed to be a Logistic Regression model.
The lift chart is based on grouping the score variable into 20 groups, which implies that
a 5% step is used for the horizontal axis containing the score.
Each point in the chart has a label that shows the number of observations falling in there,
that were used to compute the evaluation measure. 

2.- %EvaluationChart(scoredData, score=pred, event="Delinquent", model=DT, leaf=segment);
This creates a lift chart for target variable Y (the default) using the score variable PRED
in dataset SCOREDDATA. The event of interest used in the scoring model is Y="Delinquent".
The model is assumed to be a Decision Tree model.
The variable containing the tree leaf to which each observation is mapped by the tree is
SEGMENT.
The percentiles of the score variable used to make the evaluation chart are given by the
number of observations in each tree leaf.
*/
&rsubmit;
%MACRO EvaluationChart(	data,
						target=y,
						score=p,
						by=,
						event=1,
						model=LR,
						leaf=leaf,
 
						step=,
						groups=, 
						percentiles=, 

						chart=lift,
						plot=1,
						overlay=0,
						best=,
						pointlabels=0,
						points=0,
						legend=1,
						bands=0,
						bandtype=SIMUL,
						confidence=0.95,

						out=,
						outstat=,

						odsfile=,
						odsfiletype=pdf,

						libformat=,
						print=1,
						log=1,
						help=0) / store des="Plots Evaluation Charts of a scoring model";

/*----- Macro to display usage -----*/
%MACRO ShowMacroCall;
	%put EVALUATIONCHART: The macro call is as follows:;
	%put %nrstr(%EvaluationChart%();
	%put data , (REQUIRED) %quote(*** Input dataset.);
	%put target=y , %quote(       *** Target variable.);
	%put score=p , %quote(        *** Score variable(s).);
	%put by= , %quote(            *** By variables.);
	%put event=1 , %quote(        *** List of target values defining the Event of interest.);
	%put model=LR , %quote(       *** Model used to generate the score (LR, DT).);
	%put leaf=leaf , %quote(      *** Name of variable defining the leaves in a DT.);
	%put step= , %quote(          *** Step to use for the score variable in the plot.);
	%put groups= , %quote(        *** Number of percentiles for grouping the score.);
	%put percentiles= , %quote(   *** Percentiles for grouping the score.);
	%put chart=lift , %quote(     *** Type of evaluation chart.);
	%put plot=1 , %quote(         *** Make Evaluation Chart?);
	%put overlay=0 , %quote(      *** Overlay the Evaluation Charts correspnding to different groups?);
	%put best= , %quote(          *** Plot the Best Curve?);
	%put pointlabels=0 , %quote(  *** Use pointlabels showing quantile size?);
	%put points=1 , %quote(       *** Show points indicating plotting points?);
	%put legend=1 , %quote(       *** Show legend in graph?);
	%put bands=0 , %quote(        *** Show confidence bands for the Gains Chart?);
	%put bandtype=0 , %quote(     *** Type of bands to compute (POINT / SIMUL)?);
	%put confidence=0.95 , %quote(*** Confidence level for the Gains confidence bands.);
	%put out= , %quote(           *** Output dataset with the data to make the evaluation charts.);
	%put outstat= , %quote(       *** Output dataset with the KS and Gini Indexes.);
	%put odsfile= , %quote(       *** Quoted name of the ODS file to store the Evaluation Chart);
	%put odsfiletype=pdf , %quote(*** Type of the file specified in ODSFILE);
	%put libformat= , %quote(     *** Library where the target formats defined by the macro are stored);
	%put print=1 , %quote(        *** Show KS and Gini Index in the output window?);
	%put log=1) %quote(           *** Show messages in the log?);
%MEND ShowMacroCall;

%local singleData;	%* Local variable used to call %CheckInputParameters;
%local nro_data;	%* Local variable used to define the number of datasets passed;
%local error;

%if &help %then %do;
%ShowMacroCall;
%end;
%else %do;
%let error = 1;
%* Check if there are data options coming in &data. If this is the case, it is assumed
%* that there is only one dataset listed in &data. If there are no data options,
%* there may be more than one dataset listed in &data. This is necessary to define
%* the parameter SINGLEDATA= in %CheckInputParameters, and it is also used later on
%* in the macro to process the analysis datasets.
%* Also, this check avoids an error when calling %GetNroElements below which does not
%* accept data options in any of the datasets passed in the list;
%if %length(%GetDataOptions(&data)) > 0 %then %do;
	%let singleData = 1;
	%let nro_data = 1;
%end;
%else %do;
	%let singleData = 0;
	%let nro_data = %GetNroElements(&data);	%* No data options are allowed in &data in this call to %GetNroElements;
%end;

%if ~%CheckInputParameters(data=&data , var=&target &score , singleData=&singleData, macro=EVALUATIONCHART) %then %do;
	%ShowMacroCall;
%end;
%else %if %upcase(&chart) ~= LIFT and %upcase(&chart) ~= GAINS %then
	%put EVALUATIONCHART: ERROR - CHART= parameter is invalid. Valid options are LIFT and GAINS.;
%else
	%let error = 0;
%if ~&error %then %do;
/************************************* MACRO STARTS ******************************************/
/* Local variables declaration (some other variables are declared above because they are
used above) */
%local i;
%local byi bylist datai data_name out_name outstat_name n nbygroups nobs;
%local nro_quantiles;
%local colors lifti GainsEventi GainsNonEventi modeli;
%local colorLifti colorLiftBest colorEventi colorNonEventi colorEventBandi colorNonEventBandi colorEventBest colorNonEventBest;
%local vartype;			%* Type of target variable (Character or Numeric);
%local vartype1;		%* Type of target variable in the first dataset listed (only used to check consitency among target variable types);
%local varleaftype;		%* Type of LEAF variable (used when model=DT);
%local varlen;			%* DM-2012/06/06: Added a macro variable to contain the target variable length (needed to define the _BINARY informat);
%local LiftList GainsEventList GainsNonEvenList;
%local GainsEventLowerList GainsEventUpperList;
%local GainsNonEventLowerList GainsNonEventUpperList;
%local LiftLowerList LiftUpperList;
%local simul;			%* Flag indicating whether the simultaneous (or the pointwise) confidence interval was requested by the user in parameter BANDTYPE;

%*** DM-2012/06/05-START: New local variables used for the extension to multilevel target variables;
%local DT;				%* Flag indicating whether the percentiles used for the Evaluation Chart are those
						%* defined by a DISCRETE score variable, typically coming from a Decision Tree model
						%* This flag depends on the MODEL parameter and is set to true when MODEL=DT;
%local leafi;			%* Value of macro variable LEAF for each analyzed dataset or BY variable;
%local nogroups;		%* Flag indicating whether we should not group the score at all and construct the charts on the actual CDF on the raw score values (without grouping);
%local bFoundEvent;		%* Flag indicating whether the event value is found among the target values;
%local targetFormat;	%* Name used for the format of the target variable that makes it look binary (event / non-event);
%local missingValue;	%* Missing value depending on the type of the target variable (char (C) or numeric (N));
%local dollarSymbol;	%* This macro variable is either empty or equal to $ and is used to facilitate the definition of character formats and vectors;
%local eventList;		%* List of values representing the event of interest, separated by commas;
%local nonEventList;	%* The nonEventList is only used for labeling purposes (to show what represents a non-event in the plots;
%local eventLargest nonEventLargest;	%* Largest value among the values representing the event of interest and the non-events.
										%* This is used as the joker value assigned to the target variable when a value needs to be
										%* given to it (ex: to remedy the case when there are no hits for a particular quantile
										%* in the _EC_hits_ dataset --look for &target = input(...) statement below);
%local score_sum;		%* Stores the text to show in titles and labels with the formula that computes the final score used (e.g. P1 + P2);
%local TotalN;			%* Total number of observations in the analyzed dataset;
%local EventRate;
%*** DM-2012/06/05-END;

%SetSASOptions;
%ExecTimeStart;

%* Showing input parameters;
%if &log %then %do;
	%put;
	%put EVALUATIONCHART: Macro starts;
	%put;
	%put EVALUATIONCHART: Input parameters:;
	%put EVALUATIONCHART: - Input dataset = %quote(&data);
	%put EVALUATIONCHART: - target = %quote(       &target);
	%put EVALUATIONCHART: - score = %quote(        &score);
	%put EVALUATIONCHART: - by = %quote(           &by);
	%put EVALUATIONCHART: - event = %quote(        &event);
	%put EVALUATIONCHART: - model = %quote(        &model);
	%put EVALUATIONCHART: - leaf = %quote(         &leaf);
	%put EVALUATIONCHART: - step = %quote(         &step);
	%put EVALUATIONCHART: - groups = %quote(       &groups);
	%put EVALUATIONCHART: - percentiles = %quote(  &percentiles);
	%put EVALUATIONCHART: - chart = %quote(        &chart);
	%put EVALUATIONCHART: - plot = %quote(         &plot);
	%put EVALUATIONCHART: - overlay = %quote(      &overlay);
	%put EVALUATIONCHART: - best = %quote(         &best);
	%put EVALUATIONCHART: - pointlabels = %quote(  &pointlabels);
	%put EVALUATIONCHART: - points = %quote(       &points);
	%put EVALUATIONCHART: - legend = %quote(       &legend);
	%put EVALUATIONCHART: - bands = %quote(        &bands);
	%put EVALUATIONCHART: - bandtype = %quote(     &bandtype);
	%put EVALUATIONCHART: - confidence = %quote(   &confidence);
	%put EVALUATIONCHART: - out = %quote(          &out);
	%put EVALUATIONCHART: - outstat = %quote(      &outstat);
	%put EVALUATIONCHART: - outfile = %quote(      &odsfile);
	%put EVALUATIONCHART: - outfiletype = %quote(  &odsfiletype);
	%put EVALUATIONCHART: - libformat = %quote(    &libformat);
	%put EVALUATIONCHART: - print = %quote(        &print);
	%put EVALUATIONCHART: - log = %quote(          &log);
	%put;
%end;

/*----------------------------------- Parsing input parameters ------------------------------*/
%* DM-2012/06/22-START: Parse the LIBFORMAT= parameter now that the target variable is allowed to be multilevel;
%*** LIBFORMAT=;
%if %quote(&libformat) = %then
	%let libformat = WORK;
%* DM-2012/06/22-END;

%*** DATA;
%* Execute data options if only one dataset was passed;
%if &nro_data = 1 %then %do;
	%* First check whether there is a LEAF variable to keep in the analyzed dataset _EC_data_;
	%if %upcase(&model) ~= DT and %upcase(&model) ~= TREE %then
		%let leaf = ;
	data _EC_data_(keep=&target &score &by &leaf);
		set &data;
	run;
	%let _data_ = _EC_data_;
	%let data_name = %scan(&data, 1, '(');
%end;
%else %do;
	%let nro_data = %GetNroElements(&data);	%* No data options are allowed in &data!!;
	%let _data_ = &data;
%end;

%*** DM-2012/06/06-START: Parse the event value which allows the use of multilevel events;
%*** EVENT=;
%* Define the event list separated by commas;
%* First check if there is single quotation marks are used to enclose the values. In that case, they are replaced with double quotation
%* marks because single quotation marks are removed when calling %MakeList below to create the list of events separated by commas.
%* (note the use of %NRSTR --but NOT %NRBQUOTE or similar-- to enclose and mask the single and double quotation marks
%* --preceding it with the percent sign);
%if %index(%quote(&event), %nrstr(%')) > 0 %then
	%let event = %sysfunc(translate(%quote(&event), %nrstr(%"), %nrstr(%')));
%let eventList = %MakeList(%quote(&event), sep=%quote(,));
%*** DM-2012/06/06-END;

%*** TARGET=;
%* Get the target variable type and check if it is the same for all datasets.
%* (this is done in order to be able to identify the missing values);
%do i = 1 %to &nro_data;
	%let datai = %scan(&_data_, &i, ' ');
	%let vartype = %GetVarType(&datai, &target);
	%let varlen = %GetVarAttrib(&datai, &target, varlen);
	%*** DM-2012/06/06-START: Added the macro variable dollarSymbol to store the $ symbol to be used
	%*** in the definition of character formats and character arrays;
	%if %upcase(&vartype) = C %then %do;
		%let missingValue = ' ';
		%let dollarSymbol = $;
	%end;
	%else %do;
		%let missingValue = .;
		%let dollarSymbol = ;
	%end;
	%*** DM-2012/06/06-END;
	
	%* Store the var type so that I can check that the target variables in all datasets
	%* are of the same type;
	%if &i = 1 %then	
		%let vartype1 = &vartype;
	%else
		%if %upcase(&vartype) ~= %upcase(&vartype1) %then
			%let error = 1;

	%* Read the values taken by the target variable (these are the actual values, regardless of what values make the event the user
	%* is interested in analyzing, since at this point we are just reading the actual values of the target to check the macro call).
	%* The freq table is sorted by these (unformatted) values (with order=INTERNAL, which in any case is the default sorting);
	%* The order in which the values are stored is important because it plays a key role in defining the largest value of multilevel
	%* events and multilevel non-events below;
	proc freq data=&datai order=INTERNAL noprint;
		where not missing(&target);
		tables &target / out=_EC_freq_target_;
	run;
	%*** DM-2012/06/05-START: Check whether the event value is found among the target values, and count the number of target values;
	%*** If the event value is not found, raise an error and stop processing.
	%*** Multilevel target variables are now allowed: all the levels that do not correspond to the event value are grouped together
	%*** as non-event;
	%let bFoundEvent = 0;
	%put EVALUATIONCHART: Following are the values taken by the target variable %upcase(&target):;
	%let eventLargest = ;
	%let nonEventLargest = ;
	data _EC_freq_target_NonEvent_;		%* The non-event values are stored in order to create the non-event list below;
		set _EC_freq_target_ end=lastobs;
		if &target in (&eventList) then do;
			put "EVALUATIONCHART: " &target "(part of event of interest)";
			%* Update the largest value among the event values;
			call symput ('eventLargest', strip(&target));
			call symput ('bFoundEvent', strip(1));
		end;
		else do;
			put "EVALUATIONCHART: " &target;
			%* Update the largest value among the non-event values;
			call symput ('nonEventLargest', strip(&target));
			output _EC_freq_target_NonEvent_;
		end;
		if lastobs then do;
			put "EVALUATIONCHART: Total number of values: " _N_;
			call symput ('nobs', compress(_N_));
		end;
	run;
	%put EVALUATIONCHART: The number of different values taken by the target variable %upcase(&target) is &nobs..;
	%* Check if the event value was found among target values;
	%if ~&bFoundEvent %then %do;
		%put EVALUATIONCHART: ERROR - The event value(s) (&eventList) were not found among the target variable values.;
		%put EVALUATIONCHART: The macro will stop executing.;
		%let error = 1;
	%end;
	%* Add quotes to &eventLargest and nonEventLargest in case the target variable is character;
	%if %upcase(&vartype) = C %then %do;
		%let eventLargest = %quote(")&eventLargest%quote(");
		%let nonEventLargest = %quote(")&nonEventLargest%quote(");
	%end;
	%* Create the list of non-event values to be used in the graph labels / legends;
	%* Note the use of the STRIP function to remove leading and trailing blanks when adding the double quotes
	%* to the result of the MakeList macro (which I do not understand why they appear!);
	%let nonEventList = %quote(")%sysfunc(strip(%MakeListFromVar(_EC_freq_target_NonEvent_, var=&target, strip=1, sep=%quote(","), log=0)))%quote(");

	%put ;
	%put EVALUATIONCHART: The values representing the event of interest are the following:;
	%put EVALUATIONCHART: &eventList;
	%put ;
	%put EVALUATIONCHART: The non-event values are the following:;
	%put EVALUATIONCHART: &nonEventList;

	%*** DM-2012/06/05-START: Define a FORMAT and INFORMAT to be used respectively in comparisons and assignments
	%*** of values of the target variable when the target variable is multilevel;
	%*** Both the FORMAT and the INFORMAT are called the same (_BINARY);
	%*** Note that The defined format groups all event values and all non-event values so that
	%*** the target variable is considered as binary for the purposes of this analysis;
	%let targetFormat = &dollarSymbol._binary;		%* Character/Numeric format name (with/without $);
	%let targetInformat = &dollarSymbol._binary;	%* Character/Numeric informat name (same as format name, with/without $);
	proc format library=&libformat;
		%* Define a FORMAT for the target so that grouping of multilevel values can be carried out;
		%* Note that the values on the right are numbers (1, ., 0) but if the target variable is character
		%* they show up as CHARACTER formatted values;
		%* Note that it is important to consider the missing values separately, so that they are not grouped
		%* together with the 0 formatted value;
		%* It is also IMPORTANT to specify the length of the format (using the DEFAULT= option), so that the length
		%* of the formatted variable is the same as the length of the non-formatted variable. This is essential for
		%* CHARACTER target variables: if we do not specify the default length here, there will be a length mismatch
		%* in the process below (e.g. when merging the _EC_hits_ dataset in the creation of the _EC_chart_i_ dataset)
		%* which may result in truncation of the target variable values (when the length of the target variable is
		%* larger than 1) and the whole process will be messed up;
		value &targetFormat(default=&varlen)
				&eventList		= '1'
				&missingValue 	= &missingValue
				other			= '0';
		%* Define an INFORMAT in order to assign one actual value to the target variable when the event of interest is multilevel;
		%* Note that the value assigned is the largest among all the values representing the event;
		invalue &targetInformat(default=&varlen)
		%if %quote(&eventLargest) ~= %then %do;		%* &eventLargest may be empty if none of the events given in EVENT= is taken by the target variable;
				'1'				= &eventLargest
		%end;
				&missingValue 	= &missingValue
		%if %quote(&nonEventLargest) ~= %then %do;	%* &nonEventLargest may be empty if the target variable takes only the values given in the EVENT= parameter;
				'0'				= &nonEventLargest
		%end;
		;
	run;
	%* Map the LIBRARY format (which is part of the FMTSEARCH search path for formats) to the &LIBFORMAT library so that
	%* the above format definitions are found;
	libname library (&libformat);
	%*** DM-2012/06/05-END;
%end;

%*** SCORE=;
%* Check whether more than one variable is passed and if so compute the score as the sum of those variables;
%* This has an application when the target variable is multilevel NOMINAL target and the user wants to analyze
%* model performs for a set of levels of the target considered all as one level. In such case, the predicted
%* probability of each level needs to be summed up to get the predicted probability of the event of interest
%* (which is the collection of multiple levels).
%* NOTE that for multilevel ORDINAL targets, the predicted probability of a level is already the CUMULATIVE
%* probability up to that level, and therefore the SCORE variable to use is simply the score variable generated
%* for that level;
%let score_sum = &score;
%if %GetNroElements(&score) > 1 %then %do;
	%* Create a new variable in the dataset(s) that contains the new score variable to use as the sum of the given scores;
	%do i = 1 %to &nro_data;
		%let datai = %scan(&_data_, &i, ' ');
		data &datai;
			set &datai;
			%* Computation of the new score variable (note that I use only 1 underscore at the beginning because
			%* it may be the case that some particular macro creates a temporary variable named _SCORE_ (i.e. with 2 underscores)
			%* and we do not want to have overlap here;
			_SCORE = sum(of &score);
		run;
	%end;
	%* Update the value of &SCORE_SUM that is shown in titles and labels (e.g. P1 + P2);
	%let score_sum = %MakeList(&score, sep=+);
	%* Update the name of the score variable to use to generate the plots;
	%let score = _SCORE;
%end;

%*** BY=;
%* If BY= is not empty, separate the input dataset in as many data sets as the number of by
%* variables values;
%if %quote(&by) ~= %then %do;
	%if &nro_data > 1 %then %do;
		%put EVALUATIONCHART: ERROR - BY variables are not allowed when more than one dataset is passed.;
		%let error = 1;
	%end;
	%else %do;
		proc sort data=&_data_;
			by &by;
		run;
		%* Read number of by variables values and read their values too, to show in the graph legend;
		proc freq data=&_data_ noprint;
			tables %MakeList(&by, sep=*) / list out=_EC_freq_by_;
		run;
		%Callmacro(getnobs, _EC_freq_by_ return=1, nbygroups);
		%* List of by variables names and values (e.g. BY1=value1 BY2=value2);
		%let bylist = ;
		%do i = 1 %to &nbygroups;
			data _EC_data&i;
				merge &_data_ _EC_freq_by_(in=in2 firstobs=&i obs=&i);
				by &by;
				if in2;
			run;
			%* Read the values of the by variables to be shown in the legend of the graph;
			data _NULL_;
				set _EC_freq_by_(firstobs=&i obs=&i);
				call symput('byi', %MakeList(&by, sep=%quote(||' '||)));
			run;
			%* Create a list of the form BYVAR1=BYVALUE1 BYVAR2=BYVALUE2 etc., which is what is
			%* going to be shown in the legend of the graph to identify each curve;
			%CreateInteractions(&by, with=&byi, join==, allInteractions=0, macrovar=_byvaluesi_, log=0);
			%let bylist = &bylist,&_byvaluesi_;
			%** I use a comma as separator between the different by variables combination, in order 
			%** to be able to distinguish each combination of by variables when creating the graph
			%** legend;
		%end;
		%* Delete global macro variable created by %CreateInteractions;
		%symdel _byvaluesi_; quit;
		%* Pretend that the list of datasets passed in DATA= is the list of datasets just created
		%* from the original input dataset for each value of the by variables;
		%let _data_ = %MakeListFromName(_EC_data, start=1, step=1, stop=&nbygroups);
		%*** NOTE THAT THE MACRO VARIABLE nro_data IS UPDATED HERE TO REFLECT THE USE OF BY VARIABLES!!;
		%*** That is, the use of BY variables is reduced to the case when several datasets are passed.
		%*** Each BY variable combination value is associated to a different dataset whose evaluation chart is plotted;
		%let nro_data = %GetNroElements(&_data_);
	%end;
%end;

%*** STEP=, GROUPS= and PERCENTILES=;
%let nogroups = 0;
%if %quote(&percentiles) = %then %do;
	%if &step ~= %then
		%let percentiles = %MakeListFromName( , start=&step , stop=100, step=&step);
	%else %if &groups ~= %then
		%let percentiles = %MakeListFromName( , length=&groups , start=%sysevalf(100/&groups), step=%sysevalf(100/&groups));
	%else
		%let nogroups = 1;
%*		%let percentiles = %MakeListFromName( , length=10 , start=10 , step=10);
%end;
%* DM-2012/06/17: Add the 100 percentile in case it is not automatically included as one of the values
%* This happens when the STEP value is not an integer sub-multiple of 100 (e.g. STEP = 6, which will create the following
%* percentile values: 6%, 12%, ..., 96%, but 100% will NOT be included in the list by the %MakeListFromName macro call above);
%if %index(&percentiles, 100) = 0 %then
	%let percentiles = &percentiles 100;
%* Nro. of quantiles defined by the percentile values;
%let nro_quantiles = %GetNroElements(&percentiles);

%*** CONFIDENCE=;
%if %upcase(&chart) = GAINS and 
	&confidence ~= 0.80 and
	&confidence ~= 0.90 and
	&confidence ~= 0.95 and
	&confidence ~= 0.98 and
	&confidence ~= 0.99 %then %do;
	%put EVALUATIONCHART: WARNING - The requested confidence level for the Gains confidence bands is not valid.;
	%put EVALUATIONCHART: The default value (0.95) will be used.;
%end;

%*** BANDTYPE=;
%* Type of confidence band: simultaneous or pointwise;
%* Variable BANDTYPE is updated in order to use its value in labels for variables in the output dataset;
%let simul = 1;
%if %substr(%upcase(&bandtype), 1, 5) = POINT %then %do;
	%let simul = 0;
	%let bandtype = pointwise;
%end;
%else
	%let bandtype = simultaneous;

%*** OVERLAY=;
%if &overlay = %then
	%let overlay = 0;

%*** BEST=;
%if &best = %then %do;
	%* It is assumed that if the user passes multiple datasets or uses BY variables AND sets 
	%* option OVERLAY=1 is because they want to compare the evaluation charts of 2 different samples,
	%* but they do not want to compare them with the Best Curve.
	%* In addition, note that the plot of the (OVERALL) Best Curve only makes sense when the event rates
	%* are the same among the different analyzed samples!;
	%if &overlay and (&nro_data > 1 or %quote(&by) ~=) %then
		%let best = 0;
	%else
		%let best = 1;
%end;
/*-------------------------------------------------------------------------------------------*/
%if ~&error %then %do;
%* Deleting _EC_Chart_ and _EC_KSGini_ in case it exists to avoid problems with PROC APPEND;
proc datasets nolist;
	delete 	_EC_Chart_
			_EC_KSGini_;
quit;

%do i = 1 %to &nro_data;
	%* Data name;
	%let datai = %scan(&_data_, &i, ' ');

	%*** Define a dataset with the data necessary to compute the confidence limits of the Gains Charts;
	%*** Ref: "Practical Nonparametric Statistics", Conover (1980), pag. 353 and Table A14;
	%*** This data are valid when n > 40, where n is the number of observations in the dataset.
	%*** Note that n is ALWAYS the number of observations in the dataset regardless of the
	%*** quantiles used for the computation of the Gains Chart. This is because, we can think of
	%*** constructing the confidence bands for the quantized Gains Chart as first constructing
	%*** the confidence bands for the non-quantized Gains Chart (for which n is the number of
	%*** observations in the dataset) and then plotting the values of the non-quantized confidence
	%*** bands that coincide with the quantiles used for the quantized Gains Chart;
	%* Number of valid observations by target value. This is necessary to compute the quantiles
	%* of the Kolmogorov Test Statistic used to compute the condifence band, as done below;
	proc means data=&datai n noprint;
		%* DM-2016/03/19: Added the WHERE condition on non-missingnness of analyzed variables to avoid analyzing cases where all
		%* records are missing for the analysis variables.
		%* This happenned at NAT for instance when a particular BY group has all its target variable set to missing because the BY group is
		%* not intended to be included in any analysis of performance but still we want to score that BY group;
		where not missing(&target) and not missing(&score);
		%* DM-2012/06/05-START: Replaced the BY statement with the CLASS statement as I am now using a FORMAT statement 
		%* for the target variable in order to accept also MULTILEVEL variables;
		class &target;
		format &target &targetFormat..;
		%* DM-2012/06/05-END;
		var &score;
		output out=_EC_n_(drop=_TYPE_ _FREQ_) n=n;
	run;
	%* DM-2016/0319: Check if there are any data on which to compute the chart;
	%* Note that it already happenned that a particular BY group has no valid data because
	%* it is not intended to be included in the analysis (e.g. control group, which is nor training data nor validation data;
	%Callmacro(getnobs, _EC_n_ return=1, n);
	%if &n = 0 %then
		%put EVALUATIONCHART: No valid observations found for BY group &i. Analysis skipped for this group.;
	%else %do;
		%* NOTE: The Kolmogorov bands coincide with the HW (Hall & Wellner) confidence bands (computed below by PROC LIFETEST)
		%* for non-censored data;
		data _EC_KolmogorovBandWidths_;
			keep confidence &target n width;
			format confidence percent7.1;
			set _EC_n_;
			%* DM-2012/06/05-START: Added the following where condition because of the replacement of the BY statement with the CLASS statement above;
			where not missing(&target);
			%* DM-2012/06/05-END;
			confidence = 0.80; width = 1.07 / sqrt(n); output;
			confidence = 0.90; width = 1.22 / sqrt(n); output;
			confidence = 0.95; width = 1.36 / sqrt(n); output;
			confidence = 0.98; width = 1.52 / sqrt(n); output;
			confidence = 0.99; width = 1.63 / sqrt(n); output;
		run;

		%* Model type;
		%if %quote(&model) ~= %then %do;
			%if %GetNroElements(&model) = 1 %then
				%let modeli = &model;
			%else %do;
				%let modeli = %scan(&model, &i, ' ');
				%* If the list in &model has more than one element, but does not have as many
				%* elements as number of datasets listed in &data, &modeli will be empty for some
				%* dataset, and therefore the default  value of &model is used for those cases;
				%if %quote(&modeli) = %then
					%let modeli = LR;
			%end;
		%end;
		%else
			%let modeli = LR;

		%*** Standardize the value of &modeli so that it is not necessary to ask for all possible
		%*** values of the same type of model (e.g. DT or TREE). This also takes care of an invalid
		%*** value passed in parameter MODEL=, in which case the model is assumed to be LR;
		%if %upcase(&modeli) = DT or %upcase(&modeli) = TREE %then
			%let modeli = DT;
		%else
			%let modeli = LR;

		%* Define the macro variable DT and LEAF, for the current model.
		%* The variable DT is defined in order to make it easier to treat distinguish between the
		%* two cases of MODELi (DT or LR).
		%* On the other hand, the most important thing about the LEAF variable is that LEAFi is set
		%* to empty when the current model is NOT a DT, since below I do a KEEP
		%* of variable &LEAFi that variable usually does not exist in the input dataset when the model
		%* is not a DT;
		%if %upcase(&modeli) = DT %then %do;
			%let DT = 1;
			%let leafi = &leaf;
			%let varleaftype = %GetVarType(&datai, &leaf);
		%end;
		%else %do;
			%let DT = 0;
			%let leafi = ;
		%end;

		%* Eliminate missing values of &score in the input dataset and sort by descending &score;
		proc sort data=&datai(where=(not missing(&target) and &score~=.)) out=_EC_data_(keep=&target &score &leafi);
			by descending &score &leafi;
		run;

		/*----------------- Compute Lift/Gains chart with Confidence Bands ----------------------*/
		%*** The basic idea is to compute the ranks of the score variables (since the Gains and Lift values
		%*** are based on the QUANTILES of the score --and not on the score itself) over ALL the data and then
		%*** compute the CDF by target group (event/non-event), which give the Event Gains and the Non-Event Gains.
		%*** Finally the Lift curve is simply the EventGains / quantile;

		%* Compute score rank on ALL the data (regardless of TARGET value);
		%* Note the use of the FRACTION option so that we get directly the quantile values as ranking output.
		%* If we wanted to get a rank based on the observation position (based on the sorting given by the score variable)
		%* it is better to use TIES=HIGH, so that the maximum rank value is the number of observations in the dataset when
		%* ties are present --note that TIES=MEAN is the default value and this does NOT result in the maximum
		%* rank value to be the number of observations in the dataset when ties are present);
		proc rank data=_EC_data_ out=_EC_data_rank_ descending fraction;
			var &score;
			ranks quantile;
		run;

		%* Create a copy of the target variable (_TARGET_) that is binary in order to sort by that variable since we want
		%* to compute the CumHits and CumN values separately for the Event and Non-Event group.
		%* Note that PROC SORT does NOT accept any FORMAT statement (which o.w. would avoid the need
		%* to create this temporary _TARGET_ variable);
		data _EC_data_rank_;
			set _EC_data_rank_;
			_TARGET_ = put(&target, &targetFormat..);	%* _TARGET_ is a character variable;
		run;
		proc sort data=_EC_data_rank_ out=_EC_data_rank_cum_;
			by _TARGET_ quantile;
		run;

		%* Compute hits and CumHits;
		data _EC_data_rank_cum_;
			keep &target _TARGET_ &leafi &score quantile hits CumHits;
			format &target;
			format _TARGET_ &leafi &score quantile hits CumHits;
			set _EC_data_rank_cum_;
			by _TARGET_ quantile;		%* _TARGET_ is used for the FIRST. flag and QUANTILE is used for the LAST. flag;
			retain CumHits;
			retain hits;
			if first.quantile then
				hits = 0;
			if FIRST._TARGET_ then do;
				%*** Add a record with QUANTILE = 0 at the first observation of the current _TARGET_ group so that
				%*** the merge with _EC_data_surv_ below can be done seamlessly as the _EC_data_surv_ already
				%*** contains a record with QUANTILE = 0 for each _TARGET_ group;
				%* Store the current values of QUANTILE and &SCORE (which are used below to recover their original values at the first observation);
				quantile_current = quantile;
				_score_current = &score;
				%* Update the value of QUANTILE to represent the case QUANTILE = 0 and output the record;
				quantile = 0;
				CumHits = 0;
				&score = .;
				%if &DT %then %do;
					%if %upcase(&varleaftype) = C %then %do;
				&leafi = '';
					%end;
					%else %do;
				&leafi = .;
					%end;
				%end;
				output;
				* Go back to the values of QUANTILE, &SCORE and n at the first record in the input dataset; 
				quantile = quantile_current;
				&score = _score_current;
			end;
			%* Process the current record in the input dataset;
			hits + 1;
			CumHits + 1;
			%* Only OUTPUT the last occurrence of the (possibly repeated) current value of QUANTILE;
			%* Note that for any model we can have repeated values of quantile! Thus the OUTPUT _EC_data_rank_cum_ dataset
			%* may have less number of records than the INPUT _EC_data_rank_cum_ dataset after this data step is complete;
			if LAST.quantile then
				output;
		run;

		%*---------------- PROC LIFETEST to compute CDF and Confidence Bands ---------------------;
		%* Compute SURVIVAL FUNCTION using PROC LIFETEST by TARGET value (Event/Non-Event), and its CONFIDENCE BANDS;
		%* NOTES:
		%* - The default method applied to estimate the survival function is Kaplan-Meier (explicitly specified here,
		%* in case future versions change the default).
		%* - The confidence intervals/bounds are estimated using the transformation of the survival function specified
		%* by parameter CONFTYPE, which defaults to LOGLOG (= log(-log(x)), explicitly specified here,
		%* in case future versions change the default)
		%* - The confidence intervals/bounds that can be output to the OUTSURV= dataset are of 3 types:
		%*		- SDF_LCL / SDF_UCL variables 	=> contain the POINTWISE confidence intervals
		%*		- EP_LCL  / EP_UCL variables	=> contain the Equal-Precision confidence BANDS (which are proportional to the pointwise confidence intervals)
		%*		- HW_LCL  / HW_UCL variables	=> contain the Hall-Wellner confidence BANDS (which are NOT proportional to the pointwise confidence intervals, but reduce to the Kolmogorov bands for uncensored data)
		%		CONFBAND=ALL indicates that both the EP and HW confidence bands should be output to the OUTSURV= dataset besides
		%*		the pointwise confidence intervals;
		proc lifetest 	data=_EC_data_rank_
						outsurv=_EC_data_surv_
						method=KM
						alpha=%sysevalf(1-&confidence)
						conftype=LOGLOG			/* This is the default transformation applied to S(t) to compute the confidence bands */
						confband=ALL			/* This requests the pointwise confidence bands, the Equal Precision (EP) confidence bands and the Hall and Wellmer (HW) confidence bands */
						noprint plots=none;
			strata &target _TARGET_;
			format &target &targetFormat..;
			time quantile;
		run;

		%*------ Use Conovers method to compute Confidence Bands instead ------;
		/* This section was NOT updated after the changes done in Jun-2012! (because it was not used)
			I left it for reference on what the Conover method is based upon.
		data _EC_Chart_i_;
			merge _EC_Chart_i_(in=in1) _EC_KolmogorovBandWidths_(where=(confidence=&confidence));
			by &target;
			retain widthEvent widthNonEvent;
			if in1 then
				widthEvent = width;
			else do;
				widthNonEvent = width;
				delete;
			end;
			GainsEventLower = max(0, GainsEvent - widthEvent);
			GainsEventUpper = min(1, GainsEvent + widthEvent);
			GainsNonEventLower = max(0, GainsNonEvent - widthNonEvent);
			GainsNonEventUpper = min(1, GainsNonEvent + widthNonEvent);
			drop width widthEvent widthNonEvent;
		run;
		*/
		%*------ Use Conovers method to compute Confidence Bands instead ------;
		%*---------------- PROC LIFETEST to compute CDF and Confidence Bands ---------------------;


		%*----------- Compute CumHits, Gains, hits, etc. and add them to _EC_data_surv_ ----------;
		%* Compute CDF and its confidence bands;
		data _EC_data_surv_;
			format &target;
			format _TARGET_ &score;
			format quantile;
			format cdf_lcl cdf cdf_ucl hits CumHits;
			merge 	_EC_data_surv_
					_EC_data_rank_cum_;
			by _TARGET_ quantile;
			%*** Missing values of SDF_LCL and SDF_UCL are replaced with 0 when SURVIVAL = 0 because PROC LIFETEST above
			%*** --as seen by the output generated in the output window (i.e. without the NOPRINT option used above)--
			%*** sets the standard error to MISSING (and therefore also the confidence intervals SDF_LCL and SDF_UCL)
			%*** when SURVIVAL = 0 (I do not understand why...).
			%*** Recall that SURVIVAL = 0 at the observation containing the largest QUANTILE value for each value of
			%*** the _TARGET_ variable (which here should also be the last observation within each target group, as the
			%*** observations are already sorted by _TARGET_ and QUANTILE in the output dataset (_EC_DATA_SURV_)
			%*** generated by PROC LIFETEST;
			if survival in (0, 1) then do;
				sdf_lcl = survival;
				sdf_ucl = survival;
				ep_lcl = survival;
				ep_ucl = survival;
				hw_lcl = survival;
				hw_ucl = survival;
			end;
			%*** DM-2012/06/15-END;
			cdf = 1 - survival;
			%* Decide whether to compute the simultaneous confidence band ot the pointwise confidence interval;
			%if &SIMUL %then %do;
			%* Equal Precision (EP) simultaneous confidence band --> this band is proportional to the pointwise confidence interval;
			%* From Nair paper (1984) referenced in PROC LIFETEST, the band is only valid for finite x and such that a <= F(x) <= b,
			%* where a is typically 0.05 or 0.1 and b is typically 0.95. F(x) is the CDF of x. This means that this band is NOT
			%* valid towards the end values of the interval where the CDF function has a value (where F(x) = 0 and 1 respectively);
			cdf_lcl = 1 - ep_ucl;
			cdf_ucl = 1 - ep_lcl;
			%* Hall & Wellmer (HW) simultaneous confidence band --> it is equal to the Kolmogorov confidence band for uncensored data
			%* which is our case here! (I think this is a good property and this is a good reason for choosing this approach).
			%* However, I saw some cases where one of the bounds was very off w.r.t. the EP bound (e.g. upper bound of S(t) ~= 0.01
			%* was set to 0.9 (too high!) and lower bound to ~ 1E-229 (almost 0, which sounds ok for a S(t) value of 0.01, so close to 0);
			%* Note that the delta to apply for the Kolmogorov confidence bands are calculated above
			%* in the _EC_KolmogorovBandWidths_ dataset and are taken from Conovers book on nonparametric statistics;
			%* As in the EP case, this band is valid for 0 <= x <= T < Inf such that F(T) > 0, where F(x) is the CDF of x;
	%*		cdf_lcl = 1 - hw_ucl;
	%*		cdf_ucl = 1 - hw_lcl;
			%end;
			%else %do;
			%* Pointwise confidence interval (valid only to give a confidence for the S(t) of a single observation);
			cdf_lcl = 1 - sdf_ucl;
			cdf_ucl = 1 - sdf_lcl;
			%end;
		run;

		%*** For non-DT models and for charts based on grouped score variable,
		%*** categorize the QUANTILE values using the specified percentile values;
		%if ~&DT and ~&nogroups %then %do;
			%* Create the dataset containing the definition of the _quantCat FORMAT and INFORMAT.
			%* The _quantCat FORMAT is used to map the hits, Gains and related quantities to the
			%* quantile groups defined by the percentile values.
			%* The _quantCat INFORMAT is used to go back from the formatted value representing the
			%* quantile group to the single number defining the end of the quantile group
			%* (which is derived from the specified percentile values --e.g. if P3 is the formatted
			%* value representing the quantile group that includes quantile values from 0.2 to 0.3
			%* then 0.3 is the unformatted numeric value representing such quantile group, which
			%* is obtained by applying the _quantCat INFORMAT to the formatted P3 value).
			%* NOTE that the unformatted quantile values are needed for the horizontal axis of the
			%* evaluation chart representing the percentiles;
			data _ec_formats_ctrl_		(keep=fmtname type start end label sexcl eexcl hlo quantile)
				 _ec_target_quantiles_	(keep=_TARGET_ quantile);	%* _EC_TARGET_QUANTILES_ simply has the list of specified quantile values by _TARGET_ value;
				keep fmtname type start end label sexcl eexcl hlo _TARGET_ quantile;	%* HLO is used for the OTHER group;
				format fmtname type start end label sexcl eexcl hlo _TARGET_ quantile;
				array percentiles{*} P0-P&nro_quantiles (0 &percentiles);
				retain fmtname '_quantCat' type 'N';	%* TYPE = N => Numeric FORMAT;
				retain start end label;
				retain sexcl 'N' eexcl 'N';	%* Variables containing the EXCLUSION flag of the start and end values;
				retain quantile;			%* QUANTILE is a NUMERIC variable that stores the numeric quantile value of the corresponding start-end-label set;
				length start end label $20;	%* START, END and LABEL have the same length as they are interchanged when defining
											%* the INFORMAT. This length is determined by the maximum possible values to store in
											%* START, END and LABEL which is given by the number of decimals preserved by the
											%* ROUND function applied to the percentile values below;
				start = '0';
				end = '0';
				label = 'P0';
				_TARGET_ = '0';
				quantile = 0;
				%* Long way of labeling the formatted values, i.e. showing directly the specified percentile values;
				%*label = '0-' || compress(put(round(end,1E-5), 9.7));	%* The value 9.7 of the second parameter of PUT() is given by the longest possible case: 1.00000, since the percentile value is rounded to the 3rd decimal;
				output _ec_formats_ctrl_ _ec_target_quantiles_;
				_TARGET_ = '1';
				output _ec_target_quantiles_;
				%* Informat definition;
				type = 'I';					%* TYPE = I => Numeric INFORMAT. This implies that the value of LABEL must be a character-valued NUMBER (e.g. 1.3 enclosed in quotes), since LABEL is of type character!;
				start = label;				%* START and END still contian the range of values to be converted to the value specified in LABEL;
				label = end;				%* This is the value I want the input value to be converted to (note that it is a character-valued number --since variable LABEL is character!);
				end = start;				%* The difference with the format definition is that the START and END values are the formatted
											%* values and the value of LABEL is the unformatted value or the value that I want the formatted
											%* value to be converted to.;
				output _ec_formats_ctrl_;
				do i = 1 to dim(percentiles)-1;
					%* Format definition;
					type = 'N';
					start = put(percentiles(i)/100, best12.);
					end = put(percentiles(i+1)/100, best12.);
					label = 'P'||compress(put(i,best12.));	%* best12. is the format for the numeric value i;
					_TARGET_ = '0';
					quantile = percentiles(i+1)/100;
					output _ec_formats_ctrl_ _ec_target_quantiles_;
					_TARGET_ = '1';
					output _ec_target_quantiles_;
					%* Informat definition;
					type = 'I';
					start = label;
					label = end;
					end = start;
					output _ec_formats_ctrl_;
				end;
				* Last observation for OTHER;
				type = 'N';
				start = ' ';
				end = ' ';
				hlo = 'O';
				label = ' ';		%* A character missing value is represented by a blank space (see the documentation, section Language Reference Concepts -> SAS System Concepts -> Missing Values);
				quantile = .;
				output _ec_formats_ctrl_;
				%* Informat definition;
				type = 'I';
				output _ec_formats_ctrl_;
			run;
			proc sort data=_ec_formats_ctrl_;
				by fmtname type quantile;
			run;
			proc format cntlin=_ec_formats_ctrl_;
			run;
		%end;
		%else %do;
			%* Create the list of quantile values by TARGET that I need for the SQL JOINS below;
			proc sort data=_EC_data_surv_(keep=quantile) out=_EC_target_quantiles_ nodupkey;
				by quantile;
			run;
			%* Add the 2 values of _TARGET_ for each quantile;
			data _EC_target_quantiles_;
				format _TARGET_ quantile;
				set _EC_target_quantiles_;
				_TARGET_ = '0'; output;
				_TARGET_ = '1'; output;
			run;
		%end;

		%*** Compute values by all combinations of _TARGET_ and QUANTILE and at all hierarchical levels (i.e. those given by the CLASS statement in PROC MEANS);
		proc means data=_EC_data_surv_ noprint;
			%if ~&DT and ~&nogroups %then %do;
			format quantile _quantCat.;
			%end;
	%*		where quantile ~= 0;		%* Remove the 0 quantile because it was NOT originally on the dataset and these records will incorrectly contribute to the calculation of _FREQ_ and the average of &score;
			class _TARGET_ quantile;
			var &score hits CumHits cdf cdf_lcl cdf_ucl;
			output 	out=_EC_hits_(keep=_TARGET_ quantile _TYPE_ &score hits CumHits cdf cdf_lcl cdf_ucl)
					mean=&score
					max=_SCORE_MAX _HITS_MAX CumHits cdf cdf_lcl cdf_ucl
					sum=_SCORE_SUM hits
					;
		run;

		%*** For non-DT models and grouped charts, convert the QUANTILE value (wich falls anywhere within the quantile group) to the representative
		%*** number used for the quantile group, which is given by the QUANTILE column in the _EC_FORMATS_CTRL_ dataset that defines
		%*** the _quantCat format;
		%if ~&DT and ~&nogroups %then %do;
		data _EC_hits_;
			format _TARGET_ quantileEnd;
			set _EC_hits_;
			%* Quantile value corresponding to the end value of the quantile group range;
			quantileEnd = input(put(quantile, _quantCat.), _quantCat.);	%* The first _quantCat is the FORMAT, the second _quantCat is the INFORMAT;
			drop quantile;
			rename quantileEnd = quantile;
		run;
		%end;

		%*** Put this information together in order to have records for each combination of &SCORE and QUANTILE;
		%*** THIS IS THE MOST IMPORTANT PART OF THE PROCESS;
		proc sql;
			create table _EC_hits_all_ as
			select
				 q._TARGET_
				,q.quantile format=percent7.1	/* NOTE: We should NOT set the format for QUANTILE before aggregating the values with PROC MEANS, because that may derive in a truncation of the possible quantile values as a format like percent7.1 would make values 1.53% and 1.54% look the same! */
				,t3.&score						/* NOTE: There may be missing of this variable for a particular _TARGET_ because not all scores may occur for both target groups, especially when no gruoping of the score variable is requested. */
				,t0.hits as TotalN
				,t2.CumHits as TotalHits
				,(case when missing(t1.hits) then 0 else t1.hits end) as n
				,(case when missing(t3.hits) then 0 else t3.hits end) as hits
				,t3.CumHits
				/* Compute the Event and Non-Event Best Curves. In both cases, note that 1/<corresponding-event-rate> is
				the slope of the best line.
				Note also that for the Non-Event best curve, to accumulation of non events starts at the other end of the ranking,
				that is why we use (q.quantile-1) instead of just q.quantile.
				Note: the formula for the event best curve is easy. The formula for the non-event best curve comes from the following
				equality defining a straight line:
					(y - 1) / (x - 1) = (0 - 1) / (er - 1)
				where er is the EVENT rate.
				Therefore we obtain:
					y = 1 - (1 - x) * 1 / ner
				where ner = is the NON-EVENT rate and 0 < x < 1.

				Note that despite defining the best curve correctly like this, it may not show as straight line in the graph
				when the event rates are not part of the plotting points. But that is ok.
				*/
				,(case q._TARGET_ 	when '0' 	then max(0, 1 - (1 - q.quantile)*1/(t2.CumHits/t0.hits))
									when '1'	then min(q.quantile*1/(t2.CumHits/t0.hits), 1)
									else 		.
				end) as BestGains format=percent7.1
				,t3.cdf
				,t3.cdf_lcl
				,t3.cdf_ucl
			from 
			/* t0: Overall statistics: nobs = 1 */
			(select hits from _EC_hits_(where=(_TYPE_=0))) as t0,
			_EC_target_quantiles_ as q
			LEFT OUTER JOIN
			/* t1: Statistics for ALL _TARGET_ values by QUANTILE: nobs<=&nro_quantiles */
			_EC_hits_(where=(_TYPE_=1)) as t1
		  	ON q.quantile = t1.quantile
			LEFT OUTER JOIN
			/* t2: Statistics by _TARGET_ values for ALL QUANTILE values: nobs=2 (=number of _TARGET_ values (0/1)) */
			_EC_hits_(where=(_TYPE_=2)) as t2
			ON q._TARGET_ = t2._TARGET_
			/* t3: Statistics by _TARGET_ and QUANTILE values: nobs<=&nro_quantiles */
			LEFT OUTER JOIN _EC_hits_(where=(_TYPE_=3)) as t3
			ON  q._TARGET_ = t3._TARGET_
			and q.quantile = t3.quantile
			order by _TARGET_, quantile
			;
		quit;
		%* Fill in missing values because of (possible) non-existing quantiles for some of the target groups;
		%* For all variables whose missing values are filled in, the filled-in value is equal to the previous
		%* value taken by the variable, since all variables to fill in are cumulative quantities (e.g. CDF, CumHits, etc.);
		data _EC_hits_all_;
			keep   _TARGET_ &score quantile hits n CumHits CumN TotalHits TotalN BestGains cdf cdf_lcl cdf_ucl;
			format _TARGET_ &score quantile hits n CumHits CumN TotalHits TotalN BestGains cdf cdf_lcl cdf_ucl;
			set _EC_hits_all_;
			by _TARGET_ quantile;
			array current{*} 	CumHits 		cdf 		cdf_lcl 		cdf_ucl;
			array prev{*} 		CumHits_prev 	cdf_prev 	cdf_lcl_prev 	cdf_ucl_prev;
			retain 				CumHits_prev 	cdf_prev 	cdf_lcl_prev 	cdf_ucl_prev;
			%* Add the variable CumN = Cumulative value of n (where n = number of obs in each quantile);
			retain CumN;
			if first._TARGET_ then
				CumN = 0;
			CumN + n;
			do i = 1 to dim(prev);
				if first._TARGET_ then
					prev(i) = .;
				if current(i) = . then do;
					%* Set the current value to 0 if the previouus one is missing. Otherwise set it to the previous value;
					%* Recall that we are replacing the missing values of CUMULATIVE variables (CumHits and CDF) so such
					%* replacement makes sense;
					if prev(i) = . then
						current(i) = 0;
					else
						current(i) = prev(i);
				end;
			end;
			%* Update the value of the PREV variables with the CURRENT values;
			do i = 1 to dim(prev);
				prev(i) = current(i);
			end;
		run;
		%*----------- Compute CumHits, Gains, hits, etc. and add them to _EC_data_surv_ ----------;


		%*----------------- Separate the Event and Non-Event Gains into 2 datasets ---------------;
		%*** Separate the Event Gains and Non-Event Gains into 2 different datasets so that the KS and Gini Index
		%*** can be computed below;
		%* Note that _EC_data_surv_ already has the 0% quantile (in fact the survival function always
		%* starts at 0). Note also that it has the 100% quantile because the distribution computed
		%* by LIFETEST is done on the variable quantile which attains the value of 100%;
		data _EC_GainsEvent_	(keep=&target _TARGET_ &score quantile quantile_id BestGainsEvent GainsEvent GainsEventLower GainsEventUpper hits n CumHits CumN TotalHits TotalN)
			 _EC_GainsNonEvent_	(keep=&target _TARGET_ &score quantile quantile_id BestGainsNonEvent GainsNonEvent GainsNonEventLower GainsNonEventUpper hits n CumHits CumN TotalHits TotalN);
			format &target _TARGET_ &score quantile quantile_id BestGainsEvent GainsEvent GainsEventLower GainsEventUpper hits n CumHits CumN TotalHits TotalN;
			set _EC_hits_all_(keep=_TARGET_ &score quantile BestGains cdf_lcl cdf cdf_ucl hits n CumHits CumN TotalHits TotalN);
			by _TARGET_;
			retain quantile_id;
			%* Re-compute the original target variable (using the _BINARY) format;
			&target = input(_TARGET_, &targetFormat..);
			format &target;
			format BestGainsEvent BestGainsNonEvent percent7.1;
			format GainsEvent GainsEventLower GainsEventUpper percent7.1;
			format GainsNonEvent GainsNonEventLower GainsNonEventUpper percent7.1;
			if first._TARGET_ then
				quantile_id = 0;	%* NOTE-2012/06/25: QUANTILE_ID is set to 0 for the first observation of the current
									%* _TARGET_ group just to be able to apply the formula below that computes the new value
									%* of QUANTILE_ID for each observation as QUANTILE_ID+1.
									%* Clearly in order for this computation to work
									%* QUANTILE_ID already needs to have a value assigned and this value is set to 0
									%* for the first observation of the current _TARGET_ group;
			%* Create separate variables for the Gains curve for each target value;
			if _TARGET_ = '1' then do;
				quantile_id = quantile_id + 1;
				BestGainsEvent = BestGains;
				GainsEvent = cdf;
				GainsEventLower = cdf_lcl;
				GainsEventUpper = cdf_ucl;
				output _EC_GainsEvent_;
			end;
			else if _TARGET_ = '0' then do;
				quantile_id = quantile_id + 1;
				BestGainsNonEvent = BestGains;
				GainsNonEvent = cdf;
				GainsNonEventLower = cdf_lcl;
				GainsNonEventUpper = cdf_ucl;
				output _EC_GainsNonEvent_;
			end;
		run;
		%*----------------- Separate the Event and Non-Event Gains into 2 datasets ---------------;
		/*----------------- Compute Lift/Gains chart with Confidence Bands ----------------------*/


		/*-------------- Compute KS and Gini Index and prepare dataset for Plotting -------------*/
		%*** Generate the dataset containing the data for plotting (_EC_Chart_i_ and the dataset with the KS and Gini information);
		data 	_EC_Chart_i_ (drop=KS_max 	KSLower_max KSUpper_max
								   Gini   	GiniLower  	GiniUpper
								   rank		rankLower	rankUpper
									_score)
				_EC_KSGini_i_(keep=model type TotalN EventRate
								   KS_max 	KSLower_max KSUpper_max
								   Gini   	GiniLower  	GiniUpper
								   rank		rankLower	rankUpper
							  rename=(KS_max=KS 		KSLower_max=KSLower 		KSUpper_max=KSUpper
									  rank=QuantileAtKS rankLower=QuantileAtKSLower rankUpper=QuantileAtKSUpper));
			format model type TotalN EventRate;
			length model $100 type $2;	%* TYPE is type of model (LR or DT);
			merge 	_EC_GainsEvent_(in=in1 
									keep=&target _TARGET_ &score quantile quantile_id BestGainsEvent GainsEvent GainsEventLower GainsEventUpper hits n CumHits CumN TotalHits TotalN)
									end=lastobs
					_EC_GainsNonEvent_(	in=in2
										keep=&score quantile_id BestGainsNonEvent GainsNonEvent GainsNonEventLower GainsNonEventUpper
										rename=(&score=_score));
										%** From the Non-Event dataset I only keep the information related to the Non-Event
										%** as for the other variables, we want the information to come from the Event dataset
										%** (e.g. target value representing the event, #hits, etc.), except for &SCORE which may
										%** have values in one dataset but not in the other, as not all score values have to
										%** occur for each event. This is specially true when there is very few observations;
			by quantile_id;

			%* Set the value of the &SCORE variable so that no missing values remain;
			if &score = . then
				&score = _score;	%* _SCORE comes from _EC_GainsNonEvent_;

			%*** FORMAT variables;
			format EventRate Naive percent7.1;
			format BestLift Lift LiftLower LiftUpper 10.3;
			format 	KSLower 	KS 		KSUpper 		/* These variables measure the distance between the CDF functions for each target group */
					KSLower_max KS_max 	KSUpper_max		/* These variables store the actual KS values, i.e. the LARGEST distance between the CDFs */
					rankLower	rank	rankUpper
					GiniLower 	Gini 	GiniUpper		 percent7.1;

			%*** RETAIN variables;
			%if &nro_data = 1 %then %do;		%* NOTE that &NRO_DATA is 1 ONLY when one dataset is passed AND no BY variables are specified;
			retain model %upcase("&data_name");
			%end;
			%else %do;
				%* Store the by variables combinations in variable MODEL when there are BY variables,
				%* because the dataset names are temporary names that do not mean anything to the user;
				%if %quote(&by) ~= %then %do;
				retain model %upcase("&data_name (%scan(%quote(&bylist), &i, ','))");
				%end;
				%else %do;
				retain model %upcase("&datai");
				%end;
			%end;
			retain type "&modeli";
			retain idModel &i;			%* idModel is used below for constructing the final dataset _EC_Chart_ needed to generate the plot;
			retain KS_max 0;
			retain KSLower_max 0;
			retain KSUpper_max 0;
			retain rank;
			retain rankLower;
			retain rankUpper;
			retain AUC2 0;	%* AUC2 is twice AUC, so that Gini = AUC2 - 1;
			retain AUC2Lower 0;
			retain AUC2Upper 0;
			%* Retain Gini so that it has a value when it is output to the dataset _EC_KSGini_i_
			%* (after the IF LASTOBS statement at the end of the data step). Note that it is not necessary
			%* to retain KS, KSLower and KSUpper because these are generated by renaming the variables
			%* KS_max, KSLower_max and KSUpper_max above, and these _MAX variables are retained);
			retain Gini GiniLower GiniUpper;
			%* Only update the KS and Gini indexes if the record came from all 3 datasets listed above
			%* (_EC_Chart_i_, _EC_GainsEvent_ and _EC_GainsNonEvent_). This may not happen when the score variable
			%* (usually p) does not have sufficient different values so as to generate the requested number of
			%* quantiles. In this case, the dataset _EC_Chart_i has fewer records than _EC_GainsEvent_ and _EC_GainsNonEvent_;

			if in1 and in2 then do;
				%*** DM-2012/06/15-START: Bound the values of the Lower and Upper Gains Curves by the Best Curves
				%*** as the model Gains curves cannot fall outside the area defined by the Best Event Gains curve and
				%*** the Best Non-Event Gains curve;
				GainsEventUpper = min(GainsEventUpper, BestGainsEvent);		%* BestGainsEvent is upper bound for GainsEventUpper;
				GainsEventLower = max(BestGainsNonEvent, GainsEventLower);	%* BestGainsNonEvent is lower bound for GainsEventLower (very unlikely to be out of bounds);
				GainsNonEventUpper = min(GainsNonEventUpper, BestGainsEvent);		%* BestGainsEvent is ALSO the upper bound for GainsNonEventUpper (very unlikely to be out of bounds);
				GainsNonEventLower = max(BestGainsNonEvent, GainsNonEventLower);	%* BestGainsNonEvent is ALSO the lower bound for GainsNONEventLower;
				%*** DM-2012/06/15-END;

				%*** Naive and Lift values;
				Naive = quantile;
				%* Compute the Lift (which is SIMPLY = Event Gains / quantile as Lift = Model Event Gains / Naive Gains and Naive Gains = Quantile);
				if quantile = 0 then do;
					BestLift = .;
					Lift = .;
					LiftLower = .;
					LiftUpper = .;
				end;
				else do;
					BestLift = BestGainsEvent / quantile;
					Lift = GainsEvent / quantile;
					LiftLower = GainsEventLower / quantile;
					LiftUpper = GainsEventUpper / quantile;
				end;

				%************************************* KS ********************************************;
				KS = abs(GainsEvent - GainsNonEvent);
				%* Check which curve is above, whether that of the Event or that of the NonEvent,
				%* in order to compute KSLower and KSUpper;
				if GainsEvent > GainsNonEvent then do;
					KSLower = GainsEventLower - GainsNonEventUpper;
					KSUpper = GainsEventUpper - GainsNonEventLower;
				end;
				else do;
					KSLower = GainsNonEventLower - GainsEventUpper;
					KSUpper = GainsNonEventUpper - GainsEventLower;
				end;
				%* Rank of KS, KSLower and KSUpper;
				if KS > KS_max then do;
					rank = quantile;
					KS_max = KS;					
				end;
				%* Note below the inversion of rankLower and rankUpper w.r.t. KSLower and
				%* KSUpper, that is rankLower corresponds to KSUpper and rankUpper corresponds
				%* to KSLower. This is because the largest rank occurs for the worst curves
				%* which are given by the curves GainsEventLower and GainsNonEventUpper, in case
				%* the Event Gains is larger than the Non-Event Gains, and the worst KS corresponds
				%* to KSLower;
				if KSLower > KSLower_max then do;
					rankUpper = quantile;
					KSLower_max = KSLower;
				end;
				if KSUpper > KSUpper_max then do;
					rankLower = quantile;
					KSUpper_max = KSUpper;
				end;
				%***************************** AUC (Area Under the ROC Curve) ************************;
				GainsEventLag = lag(GainsEvent);
				GainsNonEventLag = lag(GainsNonEvent);
				GainsEventLowerLag = lag(GainsEventLower);
				GainsNonEventLowerLag = lag(GainsNonEventLower);
				GainsEventUpperLag = lag(GainsEventUpper);
				GainsNonEventUpperLag = lag(GainsNonEventUpper);
				if _N_ > 1 then do;
					%* DM-2012/06/15: The Area Under the Curve (AUC) is the area under the ROC curve, which is the curve
					%* that is obtained by doing the following graph:
					%*		Sensitivity (= Event Gains Curve) vs. (1 - Specificity) (= Non-Event Gains Curve)
					%* Since the values of Sensitivity and (1 - Specificity) are collected for the same values of the
					%* score quantile, we can use directly those values to compute AUC.
					%* So the current contribution of the AUC is given by (Y(i)+Y(i-1))*(X(i)-X(i-1))/2, and
					%* therefore the contribution to AUC2 (= 2*AUC) is given by: (Y(i)+Y(i-1))*(X(i)-X(i-1)),
					%* where Y = GainsEvent and X = GainsNonEvent;
					AUC2 = AUC2 + (GainsEvent + GainsEventLag)*(GainsNonEvent - GainsNonEventLag);
					%* AUC Lower and Upper bounds:
					%* Assuming that the bounds of the Event Gains and Non-Event Gains are related as follows:
					%* 	- LOWER Bound EventGains <--> UPPER Bound NonEventGains
					%* 	- UPPER Bound EventGains <--> LOWER Bound NonEventGains
					%* (i.e. when the EventGains takes it lower value, the NonEventGains takes its upper value and viceversa
					%* --which makes sense because the first situation corresponds to a less discriminating model and the second
					%* situation corresponds to a more discriminating model), we can easily compute the AUC2Lower and AUC2Upper
					%* by combining the Lower and Upper bounds of the Event and Non-Event Gains on the AUC2 formula, as follows; 
					AUC2Lower = AUC2Lower + (GainsEventLower + GainsEventLowerLag)*(GainsNonEventUpper - GainsNonEventUpperLag);
					AUC2Upper = AUC2Upper + (GainsEventUpper + GainsEventUpperLag)*(GainsNonEventLower - GainsNonEventLowerLag);
				end;
				Gini = AUC2 - 1;			%* The value of Gini at the last observation is the Gini Index;
				GiniLower = AUC2Lower - 1;
				GiniUpper = AUC2Upper - 1;
				drop 	quantile_id
						GainsEventLag 		GainsNonEventLag
						GainsEventLowerLag 	GainsNonEventLowerLag
						GainsEventUpperLag 	GainsNonEventUpperLag
						KS 		KSLower 	KSUpper
						AUC2 	AUC2Lower 	AUC2Upper;
				output _EC_Chart_i_;
			end;
			%* This IF LASTOBS1 and LASTOBS2 statement MUST be outside the IF IN1 AND IN2 condition because the condition
			%* is only true at the very last record;
			if lastobs then do;
				EventRate = TotalHits / TotalN;
				output _EC_KSGini_i_;
			end;
		run;
		/*-------------- Compute KS and Gini Index and prepare dataset for Plotting -------------*/

		%* Append current chart data to dataset containing all the charts;
		proc append base=_EC_Chart_ data=_EC_Chart_i_ FORCE;
		run;
		%* Append current KS and Gini values to dataset containing all the KS and Ginis;
		proc append base=_EC_KSGini_ data=_EC_KSGini_i_ FORCE;
		run;
	%end;
%end;

%if &print %then %do;
	title2 "KS and Gini Index for";
	title3 "Target=%upcase(&target), Score=%upcase(&score_sum)";
	proc print data=_EC_KSGini_;
	run;
	title3;
	title2;
%end;

%*----------------------------------- Output datasets ----------------------------------------;
%if %quote(&out) ~= %then %do;
	%let out_name = %scan(&out, 1, '(');
	data &out;
		keep
				model
				type
				&target
				&score
				quantile
				Naive
				BestLift
				BestGainsEvent
				BestGainsNonEvent
				LiftLower
				Lift
				LiftUpper
				GainsEventLower
				GainsEvent
				GainsEventUpper
				GainsNonEventLower
				GainsNonEvent
				GainsNonEventUpper
				hits
				n
				CumHits
				CumN
				TotalHits
				TotalN
				;
		format	model
				type;
		format  &target;		%* Remove the format for the target variable (so that we see the original value for single level events);
		format	&score
				quantile
				Naive
				BestLift
				BestGainsEvent
				BestGainsNonEvent
				LiftLower
				Lift
				LiftUpper
				GainsEventLower
				GainsEvent
				GainsEventUpper
				GainsNonEventLower
				GainsNonEvent
				GainsNonEventUpper
				hits
				n
				CumHits
				CumN
				TotalHits
				TotalN
				;
		set _EC_Chart_;
		label 	model				= "Model Name"
				type				= "Model Type (LR, DT)"
				&target				= "Event (&target=%nrbquote(&eventList))"
				&score				= "&score_sum: Score variable for &target=%nrbquote(&eventList)"
				quantile		 	= "Quantile of &score_sum"
				Naive				= "Naive 45-degree Line used in the Gains chart"
				BestLift			= "Best possible Lift curve that can be attained with this data"
				BestGainsEvent		= "Best possible Event Gains curve that can be attained with this data"
				BestGainsNonEvent	= "Best possible Non-Event Gains curve that can be attained with this data"
				Lift				= "Lift curve w.r.t. naive or random selection"
				GainsEvent			= "Event Gains (&target=%nrbquote(&eventList))"
				GainsNonEvent		= "Non-Event Gains (&target=%nrbquote(&nonEventList))"
				hits				= "Nro. of event hits in quantile"
				n 	 				= "Nro. of obs in quantile"
				CumHits				= "Cumulative nro. of event hits"
				CumN				= "Cumulative nro. of obs"
				TotalHits 			= "Total nro. of event hits"
				TotalN 				= "Total nro. of obs";
		label 	LiftLower			= "Lower Lift value based on the %sysevalf(&confidence*100)% &bandtype confidence interval (&target=%nrbquote(&eventList))"
				LiftUpper			= "Upper Lift value based on the %sysevalf(&confidence*100)% &bandtype confidence interval (&target=%nrbquote(&eventList))"
				GainsEventLower		= "Lower Event Gains value based on the %sysevalf(&confidence*100)% &bandtype confidence interval (&target=%nrbquote(&eventList))"
				GainsEventUpper		= "Upper Event Gains value based on the %sysevalf(&confidence*100)% &bandtype confidence interval (&target=%nrbquote(&eventList))"
				GainsNonEventLower	= "Lower Non-Event Gains value based on the %sysevalf(&confidence*100)% &bandtype confidence interval (&target=%nrbquote(&nonEventList))"
				GainsNonEventUpper	= "Upper Non-Event Gains value based on the %sysevalf(&confidence*100)% &bandtype confidence interval (&target=%nrbquote(&nonEventList))";
	run;
	%if &log %then %do;
		%put;
		%put EVALUATIONCHART: Output dataset %upcase(&out_name) created, with data necessary to produce;
		%put EVALUATIONCHART: a LIFT and a GAINS Chart, with confidence bands.;
	%end;
%end;

%if %quote(&outstat) ~= %then %do;
	%let outstat_name = %scan(&outstat, 1, '(');
	data &outstat;
		set _EC_KSGini_;
		label 	model				= "Model Name"
				type				= "Model Type (LR, DT)"
				TotalN				= "Total number of obs"
				EventRate			= "Event Rate"
				KSLower				= "Lower KS value based on the %sysevalf(&confidence*100)% confidence bands of the Gains Curves"
				KS					= "KS value"
				KSUpper				= "Upper KS value based on the %sysevalf(&confidence*100)% confidence bands of the Gains Curves"
				QuantileAtKSLower	= "Quantile at which the Lower KS value occurs"
				QuantileAtKS		= "Quantile at which the KS value occurs"
				QuantileAtKSUpper	= "Quantile at which the Upper KS value occurs"
				GiniLower			= "Lower Gini Index value based on the %sysevalf(&confidence*100)% confidence bands of the Gains Curves"
				Gini				= "Gini Index"
				GiniUpper			= "Upper Gini Index value based on the %sysevalf(&confidence*100)% confidence bands of the Gains Curves"
				;
	run;
	%if &log %then %do;
		%put;
		%put EVALUATIONCHART: Output dataset %upcase(&outstat_name) created, with the Model KS and Gini Index.;
	%end;
%end;
%*--------------------------------------------------------------------------------------------;


%*---------------------------------- Evaluation Chart ----------------------------------------;
%if &plot %then %do;
	%* Set the maximum for legend area to 50 percent (the default is 20 percent);
	ods graphics / MAXLEGENDAREA=50;
	%if %quote(&odsfile) ~= %then %do;
		%if %upcase(&odsfiletype) = HTML %then %do;
			ods &odsfiletype body=&odsfile;
		%end;
		%else %do;
			ods &odsfiletype file=&odsfile;
		%end;
	%end;

	%* Footnotes showing the event definition;
	footnote1 "Event: %upcase(&target)=%nrbquote(&eventList)";
	footnote2 "Non-Event: %upcase(&target)=%nrbquote(&nonEventList)";

	%* Define colors to use in the graph;
	%let colors = %Colors(n=%eval(&nro_data+1));
	%* Remove the green color from the list of colors because this is reserved for the Best Curve color;
	%let colors = %RemoveFromList(&colors, green, log=0); 

	%if &nro_data = 1 %then %do;	%* NOTE that &NRO_DATA is 1 ONLY when one dataset is passed AND no BY variables are specified;
		%* Add the POINTLABEL information (by concatenating variables hits and n) if pointlabels are requested;
		%if &pointlabels %then %do;
		data _EC_Chart_;
			set _EC_Chart_;
			length pointlabelEvent pointlabelNonEvent $25;
			pointlabelEvent = compress( put(hits, best12.) ) || ' / ' || compress( put(n,best12.) );
			pointlabelNonEvent = compress( put(n-hits, best12.) ) || ' / ' || compress( put(n,best12.) );
		run;
		%end;
		%* Graph titles;
		%if %upcase(&chart) = LIFT %then %do;
		title1 "Lift Chart";
		%end;
		%else %if %upcase(&chart) = GAINS %then %do;
		title1 "Gains Chart";
		%end;
		title2 height=9pt "Dataset = %upcase(&data); Target = %upcase(&target); Score = %upcase(&score_sum)";

		proc sgplot data=_EC_Chart_
					%if ~&legend %then %do; NOAUTOLEGEND %end;
					%if %upcase(&chart) = LIFT %then %do;
					description="Lift Chart for %upcase(&data_name)"
					%end;
					%else %if %upcase(&chart) = GAINS %then %do;
					description="Gains Chart for %upcase(&data_name)"
					%end;
					;
			%if %upcase(&chart) = LIFT %then %do;
			series x=quantile y=Lift 					/ legendlabel="Model Lift" lineattrs=(color="%scan(&colors, 1)")
															%if &points %then %do; markers markerattrs=(color="%scan(&colors, 1)" symbol=CircleFilled) %end;
															%if &pointlabels %then %do; datalabel=pointlabelEvent; %end;;
					%if &bands %then %do;
					series x=quantile y=LiftLower		/ legendlabel="%sysevalf(&confidence*100)% Lower/Upper Bound"
														 	lineattrs=(color="%scan(&colors, 1)" pattern=MediumDash);
					series x=quantile y=LiftUpper 		/ legendlabel="%sysevalf(&confidence*100)% Lower/Upper Bound"
														 	lineattrs=(color="%scan(&colors, 1)" pattern=MediumDash);
					%end;
				%if &best %then %do;
				series x=quantile y=BestLift 			/ legendlabel="Best Lift"  lineattrs=(color="green")
															%if &points %then %do; markers markerattrs=(color="green" symbol=StarFilled) %end;;
				%end;
			%end;
			%else %if %upcase(&chart) = GAINS %then %do;
			series x=quantile y=GainsEvent 				/ legendlabel="Event Gains"
													 	  lineattrs=(color="blue")
															%if &points %then %do; markers markerattrs=(color="blue" symbol=CircleFilled) %end;
															%if &pointlabels %then %do; datalabel=pointlabelEvent; %end;;
			series x=quantile y=GainsNonEvent 			/ legendlabel="Non-Event Gains"
													 	  lineattrs=(color="red")
															%if &points %then %do; markers markerattrs=(color="red" symbol=CircleFilled) %end;
															%if &pointlabels %then %do; datalabel=pointlabelNonEvent; %end;;
				%if &bands %then %do;
				series x=quantile y=GainsEventLower		/ legendlabel="%sysevalf(&confidence*100)% Lower/Upper Bound"
													 	  lineattrs=(color="blue" pattern=MediumDash);
				series x=quantile y=GainsEventUpper 	/ legendlabel="%sysevalf(&confidence*100)% Lower/Upper Bound"
													 	  lineattrs=(color="blue" pattern=MediumDash);
				series x=quantile y=GainsNonEventLower	/ legendlabel="%sysevalf(&confidence*100)% Lower/Upper Bound"
													 	  lineattrs=(color="red" pattern=MediumDash);
				series x=quantile y=GainsNonEventUpper	/ legendlabel="%sysevalf(&confidence*100)% Lower/Upper Bound"
													 	  lineattrs=(color="red" pattern=MediumDash);
				%end;
			%if &best %then %do;
			series x=quantile y=BestGainsEvent 			/ legendlabel="Event Best Curve"
														  lineattrs=(color="green")
															%if &points %then %do; markers markerattrs=(color="green" symbol=StarFilled) %end;;
			series x=quantile y=BestGainsNonEvent 		/ legendlabel="Non-Event Best Curve"
														  lineattrs=(color="green" pattern=LongDash)
															%if &points %then %do; markers markerattrs=(color="green" symbol=StarFilled) %end;;
			%end;
			%* The Naive curve goes at the bottom so that it appears last in the legend;
			series x=quantile y=Naive					/ legendlabel="Naive" lineattrs=(color="black" pattern=dash); 
			%end;
			xaxis grid 	label="Percentile";
			yaxis grid 	%if %upcase(&chart) = LIFT %then %do; 			label="Lift"; 					%end;
						%else %if %upcase(&chart) = GAINS %then %do; 	label="% Captured Response"; 	%end;	;
		run;
		title2;
		title1;
	%end;
	%else %do;	%* &nro_data > 1;
		%* Plot all the lift curves and the best curve in the same graph;
		%* The following data step creates one column for each evaluation curve to plot
		%* so that they can be overlayed on the same graph;
		data _EC_Chart_;
			set _EC_Chart_;
			%let LiftList = %MakeList(%MakeListFromName(, length=&nro_data, start=1, step=1), prefix=Lift);
			%let GainsEventList = %MakeList(%MakeListFromName(, length=&nro_data, start=1, step=1), prefix=GainsEvent);
			%let GainsNonEventList = %MakeList(%MakeListFromName(, length=&nro_data, start=1, step=1), prefix=GainsNonEvent);
			array vLift{*} &LiftList BestLift;
			array vGainsEvent{*} &GainsEventList BestGainsEvent;
			array vGainsNonEvent{*} &GainsNonEventList BestGainsNonEvent;
			format &GainsEventList BestGainsEvent &GainsNonEventList BestGainsNonEvent percent7.1;
			%** Note that it is important that the names for the columns corresponding to the
			%** evaluation curves for the different datasets be called <evaluation>&data
			%** (as opposed to &data<evaluation>), for 2 reasons:
			%** - In the dataset the same type of evaluation for the different datasets are
			%** placed all together and it is easier to make plots in Excel of the same
			%** evaluation measure.
			%** - It avoids the problem of having the same names for two different columns
			%** if one of the datasets being evaluated is called BEST (since for ex. there would
			%** be two columns named BestLift);
			%if &bands %then %do;
				%if %upcase(&chart) = GAINS %then %do;
					%let GainsEventLowerList = %MakeList(%MakeListFromName(, length=&nro_data, start=1, step=1), prefix=GainsEvent, suffix=Lower);
					%let GainsEventUpperList = %MakeList(%MakeListFromName(, length=&nro_data, start=1, step=1), prefix=GainsEvent, suffix=Upper);
					%let GainsNonEventLowerList = %MakeList(%MakeListFromName(, length=&nro_data, start=1, step=1), prefix=GainsNonEvent, suffix=Lower);
					%let GainsNonEventUpperList = %MakeList(%MakeListFromName(, length=&nro_data, start=1, step=1), prefix=GainsNonEvent, suffix=Upper);
					array vGainsEventLower{*} &GainsEventLowerList;
					array vGainsEventUpper{*} &GainsEventUpperList;
					array vGainsNonEventLower{*} &GainsNonEventLowerList;
					array vGainsNonEventUpper{*} &GainsNonEventUpperList;
					format &GainsEventLowerList &GainsEventUpperList &GainsNonEventLowerList &GainsNonEventUpperList percent7.1;
				%end;
				%else %if %upcase(&chart) = LIFT %then %do;
					%let LiftLowerList = %MakeList(%MakeListFromName(, length=&nro_data, start=1, step=1), prefix=Lift, suffix=Lower);
					%let LiftUpperList = %MakeList(%MakeListFromName(, length=&nro_data, start=1, step=1), prefix=Lift, suffix=Upper);
					array vLiftLower{*} &LiftLowerList;
					array vLiftUpper{*} &LiftUpperList;
				%end;
			%end;
			array vhits{*} 				hits1-hits&nro_data.;
			array vn{*} 				n1-n&nro_data.;
			%* Character variables containing the Event and Non-Event pointlabels to show (= #hits(0/1), #n);
			array vpointlabelEvent{*} 		$25	pointlabelEvent1-pointlabelEvent&nro_data.;
			array vpointlabelNonEvent{*} 	$25	pointlabelNonEvent1-pointlabelNonEvent&nro_data.;
			vlift(idModel) = Lift;
			vGainsEvent(idModel) = GainsEvent;
			vGainsNonEvent(idModel) = GainsNonEvent;
			%if &bands %then %do;
			if idModel <= &nro_data then do;
			%** The idModel <= &nro_datda condition is used because there is no confidence bands
			%** for the Best Gains curves;
				%if %upcase(&chart) = GAINS %then %do; 
				vGainsEventLower(idModel) = GainsEventLower;
				vGainsEventUpper(idModel) = GainsEventUpper;
				vGainsNonEventLower(idModel) = GainsNonEventLower;
				vGainsNonEventUpper(idModel) = GainsNonEventUpper;
				%end;
				%else %if %upcase(&chart) = LIFT %then %do;
				vLiftLower(idModel) = LiftLower;
				vLiftUpper(idModel) = LiftUpper;
				%end;
			end;
			%end;
			vhits(idModel) = hits;
			vn(idModel) = n;
			vpointlabelEvent(idModel) = compress( put(hits, best12.) ) || ' / ' || compress( put(n,best12.) );
			vpointlabelNonEvent(idModel) = compress( put(n-hits, best12.) ) || ' / ' || compress( put(n,best12.) );
			keep 	model
					quantile
					Naive
					&LiftList BestLift
					&GainsEventList BestGainsEvent
					&GainsNonEventList BestGainsNonEvent
					%if &bands %then %do;
						%if %upcase(&chart) = GAINS %then %do;
						&GainsEventLowerList &GainsEventUpperList
						&GainsNonEventLowerList &GainsNonEventUpperList
						%end;
						%else %if %upcase(&chart) = LIFT %then %do;
						&LiftLowerList &LiftUpperList
						%end;
					%end;
					hits1-hits&nro_data.
					n1-n&nro_data.
					pointlabelEvent1-pointlabelEvent&nro_data.
					pointlabelNonEvent1-pointlabelNonEvent&nro_data.;
		run;

		%* Graph titles;
		%if %upcase(&chart) = LIFT %then %do;
			title1 "Lift Charts";
		%end;
		%else %if %upcase(&chart) = GAINS %then %do;
			title1 "Gains Charts";
		%end;
		title2 height=9pt "Dataset = %upcase(&data); Target = %upcase(&target); Score = %upcase(&score_sum)";

		%if ~&overlay %then %do;
		proc sort data=_EC_Chart_;
			by model quantile;
		run;
		PROC SGPANEL data=_EC_Chart_
		%end;
		%else %do;
		PROC SGPLOT data=_EC_Chart_
		%end;
					%if ~&legend %then %do; NOAUTOLEGEND %end;
					%if %upcase(&chart) = LIFT %then %do;
						%if %quote(&by) = %then %do; description="Lift Charts" %end;
						%else %do; description="Lift Chart for %upcase(&data)" %end;
					%end;
					%else %if %upcase(&chart) = GAINS %then %do;
						%if %quote(&by) = %then %do; description="Gains Charts" %end;
						%else %do; description="Gains Chart for %upcase(&data)" %end;
					%end;
					;
			%if ~&overlay %then %do;
			PANELBY model;
			where upcase(model) ~= "BEST";
			%end;
			%if %upcase(&chart) = LIFT %then %do;
				%do i = 1 %to &nro_data;
					%let Lifti = %scan(&LiftList, &i, ' ');
					%let colorLifti = %scan(&colors, &i);
					%let colorLiftBest = green;
					series x=quantile y=&Lifti 		/ lineattrs=(color="&colorLifti")
														%if &points %then %do; markers markerattrs=(color="&colorLifti" symbol=CircleFilled) %end;
														%if &pointlabels %then %do; datalabel=pointlabelEvent&i %end;
														%if %quote(&by) ~= %then %do; legendlabel="Lift (%scan(%quote(&bylist), &i, ','))" %end;
														%else %do; legendlabel="Lift for %upcase(%scan(&_data_, &i, ' '))" %end;
														;
					%if &bands %then %do;
						series x=quantile y=&Lifti.Lower		/ legendlabel="%sysevalf(&confidence*100)% Lower/Upper Bound"
																	lineattrs=(color="&colorLifti" pattern=MediumDash);
						series x=quantile y=&Lifti.Upper		/ legendlabel="%sysevalf(&confidence*100)% Lower/Upper Bound"
																	lineattrs=(color="&colorLifti" pattern=MediumDash);
					%end;
				%end;
				%if &best %then %do;
					series x=quantile y=BestLift 	/ lineattrs=(color="&colorLiftBest")
														%if &points %then %do; markers markerattrs=(color="&colorLiftBest" symbol=StarFilled) %end;
														legendlabel="Best"
														;
				%end;
			%end;
			%else %if %upcase(&chart) = GAINS %then %do;
				%do i = 1 %to &nro_data;
					%let GainsEventi = %scan(&GainsEventList, &i, ' ');
					%let GainsNonEventi = %scan(&GainsNonEventList, &i, ' ');
					%let colorEventi = %scan(&colors, %eval(2*&i-1));
					%let colorNonEventi = %scan(&colors, %eval(2*&i));
					%let colorEventBandi = &colorEventi;
					%let colorNonEventBandi = &colorNonEventi;
					%let colorEventBest = green; %* %scan(&colors, %eval(2*&nro_data+1));
					%let colorNonEventBest = green; %* %scan(&colors, %eval(2*&nro_data+2));
					series x=quantile y=&GainsEventi		/ lineattrs=(color="&colorEventi")
																%if &points %then %do; markers markerattrs=(color="&colorEventi" symbol=CircleFilled) %end;
																%if &pointlabels %then %do; datalabel=pointlabelEvent&i %end;
																/* The following LEGENDLABEL statement shows either the dataset name
																or the BY variable values depending on whether BY variables are passed */
																%if %quote(&by) ~= %then %do; legendlabel="Event Gains (%scan(%quote(&bylist), &i, ',')))" %end;
																%else %do; legendlabel="Event Gains for %upcase(%scan(&_data_, &i, ' '))" %end;
																;
					series x=quantile y=&GainsNonEventi		/  lineattrs=(color="&colorNonEventi")
																%if &points %then %do; markers markerattrs=(color="&colorNonEventi" symbol=CircleFilled) %end;
																%if &pointlabels %then %do; datalabel=pointlabelNonEvent&i %end;
																/* The following LEGENDLABEL statement shows either the dataset name
																or the BY variable values depending on whether BY variables are passed */
																%if %quote(&by) ~= %then %do; legendlabel="Non-Event Gains (%scan(%quote(&bylist), &i, ',')))" %end;
																%else %do; legendlabel="Non-Event Gains for %upcase(%scan(&_data_, &i, ' '))" %end;
																;
					%if &bands %then %do;
						series x=quantile y=&GainsEventi.Lower		/ legendlabel="%sysevalf(&confidence*100)% Lower/Upper Bound"
																	  lineattrs=(color="&colorEventi" pattern=MediumDash);
						series x=quantile y=&GainsEventi.Upper		/ legendlabel="%sysevalf(&confidence*100)% Lower/Upper Bound"
																	  lineattrs=(color="&colorEventi" pattern=MediumDash);
						series x=quantile y=&GainsNonEventi.Lower	/ legendlabel="%sysevalf(&confidence*100)% Lower/Upper Bound"
																	  lineattrs=(color="&colorNonEventi" pattern=MediumDash);
						series x=quantile y=&GainsNonEventi.Upper	/ legendlabel="%sysevalf(&confidence*100)% Lower/Upper Bound"
																	  lineattrs=(color="&colorNonEventi" pattern=MediumDash);
					%end;
				%end;
				%if &best %then %do;
					series x=quantile y=BestGainsEvent				/ lineattrs=(color="&colorEventBest" pattern=solid)
																		%if &points %then %do; markers markerattrs=(color="&colorEventBest" symbol=StarFilled) %end;
																		legendlabel="Event Best Curve";
					series x=quantile y=BestGainsNonEvent			/ lineattrs=(color="&colorNonEventBest" pattern=LongDash)
																		%if &points %then %do; markers markerattrs=(color="&colorNonEventBest" symbol=StarFilled) %end;
																		legendlabel="Non-Event Best Curve";
				%end;
				%* The Naive curve goes at the bottom so that it appears last in the legend;
				series x=quantile y=Naive						/ lineattrs=(color="black" pattern=dash) legendlabel="Naive";
			%end;
			%if ~&overlay %then %do; colaxis %end; %else %do; xaxis %end; grid 	label="Percentile";
			%if ~&overlay %then %do; rowaxis %end; %else %do; yaxis %end; grid 	%if %upcase(&chart) = LIFT %then %do; 			label="Lift"; 					%end;
																				%else %if %upcase(&chart) = GAINS %then %do; 	label="% Captured Response"; 	%end;	;
		run;
	%end;	%* &nro_data > 1;
	footnote2;
	footnote1;
	title2;
	title1;

	%* Reset the value of MAXLEGENDAREA option to its default;
	ods graphics / reset=MAXLEGENDAREA;
	%if %quote(&odsfile) ~= %then %do;
	ods &odsfiletype close;
	%end;
%end;

proc datasets nolist;
	delete 
			_EC_data_
			_EC_data_rank_
			_EC_data_rank_cum_
			_EC_data_surv_
			_EC_Chart_
			_EC_Chart_i_
			_EC_formats_ctrl_
			_EC_freq_by_
			_EC_freq_target_
			_EC_freq_target_NonEvent_
			_EC_GainsEvent_
			_EC_GainsNonEvent_
			_EC_hits_
			_EC_hits_all_
			_EC_KolmogorovBandWidths_
			_EC_KSGini_
			_EC_KSGini_i_
			_EC_n_
			_EC_target_quantiles_
			%if %quote(&by) ~= %then
				%do i = 1 %to &nbygroups;
					_EC_data&i
				%end;;
quit;

%* Delete definition of temporary formats;
proc catalog catalog=formats;
	%if ~&DT and ~&nogroups %then %do;
	delete _quantCat(entrytype=format) _quantCat(entrytype=infmt);
	%end;
	%if %upcase(&libformat) = WORK %then %do;
		%if %upcase(&vartype) = C %then %do;
			%* The first character of &TARGETFORMAT is the dollay sign $, which is not part of the catalog entry name, so I remove it;
			delete %substr(&targetFormat.,2) (entrytype=formatC) %substr(&targetFormat.,2) (entrytype=infmtC);
		%end;
		%else %do;
			delete &targetFormat.(entrytype=format) &targetFormat.(entrytype=infmt);
		%end;
	%end;
quit;

%if &log %then %do;
	%put;
	%put EVALUATIONCHART: Macro ends;
	%put;
%end;

%end; 	%* if ~&error (second IF);
%ExecTimeStop;
%ResetSASOptions;
%end;	%* if ~&error (first IF);
%end;	%* if &help;
%MEND EvaluationChart;
