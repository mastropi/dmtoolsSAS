/* MACRO %Score
Version:		1.00
Author:			Daniel Mastropietro
Created:		19-May-2016
Modified:		29-May-2016

DESCRIPTION:
Score a new dataset based on the estimated parameters of a regression model.

The model may contain categorical variables with formats which are used to generate
the dummy variables needed to score the data, using PROC TRANSREG.

The input dataset should contain all variables present in the model (except the dummy variables
corresponding to any categorical variables present, which are calculated by this macro).

Optionally the generated score can be compared to a previously generated one.

The score is computed using PROC SCORE.

USAGE:
%Score(	data,						*** Dataset to score containing the variables in the model.
		dataparams=_PARAMS_, 		*** Dataset with the regression model parameters generated by OUTEST= (single record)
		datacatref=,				*** Dataset with the reference level of the categorical variables in the model.
		datacat=,					*** Dataset with the info about the categorical variables in the model.
		ref=first,					*** Reference level for the categorical variables given in DATACAT.
		targetbinary=1,				*** Whether the target is binary (e.g. logistic regression).
		id=, 						*** ID variables.
		copy=,						*** Blank-separated list of variables to copy to the output dataset.
		score=,						*** Name of the score variable that will contain the score computed by PROC SCORE.
		response=p,					*** Name of the response variable associated to the score
									*** (e.g. sigmoid transformation of score in logistic model).
		datacheck=,					*** Dataset containing a score or response variable to use as comparison.
		scorecheck=,				*** Score variable against which the SCORE variable should be compared
									*** (SCORE and SCORECHECK should have different names).
		responsecheck=,				*** Response variable against which the RESPONSE variable should be compared
									*** (RESPONSE and RESPONSECHECK should have different names).
		outcheck=,					*** Output dataset used for the comparison, containing only matching observations.
		out=,						*** Output dataset containing the score and response values.
		plot=1,						*** Show plots?
		log=1);						*** Show messages in the log?

REQUIRED PARAMETERS:
- data:					Input dataset to score. Data options are allowed.
						It should contain all the regression model variables used during the model fit.
						Categorical variables should be the original ones.
						Any formats used for categorical variables as defined in the DATACAT or DATACATREF
						dataset must exist.

OPTIONAL PARAMETERS:
- dataparams:			Dataset with the regression model parameters.
						Typically generated by the OUTEST= option of the procedure used to fit the model.
						It should contain just one record and as many columns as model variables,
						where categorical variables have been replaced with the corresopnding dummy variables.
						default: _PARAMS_

- datacatref, datacat:	Datasets containing the categorical variable information with at least the following columns:
						- var:		categorical variable name.
						- fmtname:	format name to use for the categorical variable.
						- fmtvalue: format value for the category or the reference level.
						The DATACATREF dataset should have only one record per variable, containing the reference
						level used for the variable during the model fit in variable FMTVALUE.
						When categorical variables exist in the model, at least one of the datasets
						should be given. When both are given, DATACATREF has preference over DATACAT.
						default: empty

- ref:					Reference level for the categorical variables. Only used then the DATACAT is given
						and DATACATREF is empty.
						Any value is accepted, but when the value is not First or Last, that same value
						is used for all categorical variables in the model.
						default: first

- targetbinary			Whether the model target variable is binary, as is the case in a logistic regression model.
						When the target variable is binary, both the SCORE and the RESPONSE variables
						are computed and stored in the output dataset. Otherwise, only the SCORE variable
						is computed and stored.
						Possible values: 0 => not binary, 1 => binary
						default: 1

- id:					When checking the score against DATACHECK, the ID variables should be unique,
						as a unique index is created on them in order to match the observations with the
						scored dataset.
						When empty, observations are matched by observation number and a warning is shown.
						These variables are copied to the output dataset.
						default: empty

- copy:					Blank-separated list of variables to copy to the output dataset.
						default: empty

- score					Name of the score variable that should contain the score generated by PROC SCORE.
						default: empty

- response				Name of the response variable associated to the score
						(e.g. sigmoid transformation of score in logistic model).
						default: p

- scorecheck			Score variable in the DATA or DATACHECK dataset against which the SCORE variable should
						be compared.
						It must have a different name than the SCORE variable.
						default: empty

- responsecheck			Response variable in the DATA or DATACHECK dataset against which the RESPONSE variable
						should be compared.
						It must have a different name than the RESPONSE variable.
						default: empty

- datacheck:			Dataset containing the SCORECHECK and/or RESPONSECHECK variables
						against which the score and/or response variables calculated by this macro
						should be compared.
						Cases are matched by the ID variables if given, or by observation number
						if no ID variables are given, in which case it is assumed that both
						datasets have the same number of observations.
						Only matching cases are compared.
						default: empty

- outcheck:				Output dataset containing all the variables in the DATACHECK dataset but just
						the records matching the input dataset that are used for the score comparison.
						This is only created if a DATACHECK dataset is given.
						The OUTCHECK dataset also contains the score or response variable in the input
						dataset and the difference between that score or response variable and the
						scorecheck or responsecheck variable existing in the DATACHECK dataset.
						The variable containing this difference is called _PRED_DIFF.
						default: empty

- out:					Output dataset containing the score and/or response variables as well as any
						specified ID and COPY variables.
						If no dataset is given, the score is stored in dataset _SCORE_PRED_.
						default: empty

- plot:					Show plots on the computed scores and comparison analysis?
						When yes, a distribution of the score or response variable is shown,
						and a distribution of the difference between the SCORE and SCORECHECK or
						the RESPONSE and RESPONSECHECK variable is shown.
						Possible values: 0 => not binary, 1 => binary
						default: 1

- log:					Show messages in the log?
						Possible values: 0 => not binary, 1 => binary
						default: 1

NOTES:
1.- The variables in the model that are not used when calculating the score are listed at the end of the process
with a WARNING message.

OTHER MACROS AND MODULES USED IN THIS MACRO:
- %ExecTimeStart
- %ExecTimeStop
- %KeepInList
- %MakeList
- %MakeListFromVar
- %RemoveFromList
- %ResetSASOptions
- %SetSASOptions

SEE ALSO:
- %FreqMult: to generate the distribution of the categorical variables present in the model that is needed
by this macro 
*/
&rsubmit;
%MACRO Score(	data,
				dataparams=_PARAMS_,
				datacatref=,
				datacat=,
				ref=first,
				targetbinary=1,
				id=,
				copy=,
				score=,
				response=p,
				datacheck=,
				scorecheck=,
				responsecheck=,
				outcheck=,
				out=,
				outfile=,
				plot=1,
				log=1) / store des="Computes the score of a regression model on a new dataset";
/*
TODO:
-[DONE] Warn the user when there are less variables used in in PROC SCORE than there exist in the original model.
Show the list of variables removed from the scoring formula.
- Implement the OUTFILE= parameter that stores the SAS code used to generate the score into a file (instead of the MPRINT way
currently implemented).
*/

%SetSASOptions;
%ExecTimeStart;

%local datavars;		%* Variables present in the input dataset to score;
%local formats;			%* Formats of variables (containing variable name and format name);
%local idst;			%* ID Statement to use in PROC TRANSREG;
%local modelvars;		%* List of model variables;
%local modelvars_use;	%* List of model variables to use in PROC SCORE;
%local reflevels;		%* List of reference levels of categorical variables;
%local reflevels_str;	%* Reference levels string to use in the ZERO= option of the CLASS statement of PROC TRANSREG;
%local checkvar;		%* Variable name in the DATACHECK dataset containing the score to check (either &SCORECHECK or &RESPONSECHECK);
%local vardummies;		%* List of dummy variables generated by PROC TRANSREG;
%local scoreInParams;	%* Name of the score variable as stored in the DATAPARAMS dataset;

%* Macro variables that store current option settings;
%local option_mprint;
%local option_varlenchk;

/*------------------------------------ Parse input parameters -------------------------------*/
%*** ID=;
%if %quote(&id) ~= %then
	%let idst = id &id;

%*** TARGETTYPE=;
%if &targetbinary %then %do;
	%let responsevar = &response;
	%let checkvar = &responsecheck;
%end;
%else %do;
	%let responsevar = &score;
	%let checkvar = &scorecheck;
%end;
/*------------------------------------ Parse input parameters -------------------------------*/


%* Store current options;
%let option_mprint = %sysfunc(getoption(mprint));
%let option_varlenchk = %sysfunc(getoption(varlenchk));


%*************************
%*** 1.- Data prep
%*************************;
%* Store the list of model variables in macro variable MODELVARS (taken from the DATAPARAMS dataset);
%* Note that these model variables in general are NOT the original variables when fitting the model
%* except when the regression model does not have any categorical variables. In fact, these model variables
%* include the variable dummies instead of the original categorical variable names;

%* Read the original name of the score variable as stored in the DATAPARAMS dataset (_NAME_ column);
data _NULL_;
	set &dataparams;
	call symput ('scoreInParams', _NAME_);
run;

%* List of model variables taken form the DATAPARAMS dataset;
proc transpose data=&dataparams out=_score_modelvars_ name=var;
run;
data _score_modelvars_;
	set _score_modelvars_;
	where not missing(&scoreInParams) and var not in ("Intercept", "_LNLIKE_");
run;
%let modelvars = %MakeListFromVar(_score_modelvars_, var=var, log=0);


%*************************
%*** 2.- Dummy variables
%*************************;
%* Dummy variables for the categorical variables;
%* The generated dummy variables are saved into macro variable &VARDUMMIES;
%* NOTES:
%* - We use the ZERO="<var1-ref-level>" "<var2-ref-level>" ... in the CLASS statement in order to define the reference level
%* of each categorical variable;
%* Note that we should NOT use ZERO=FIRST or ZERO=LAST because such level (the first or the last one) is determined by the
%* categorical values present in the dataset to score...!;
%* - The reference value for formatted variables should be set to the formatted value, NOT the unformatted one;
%* - The reference value for numeric unformatted variables should still be enclosed in quotes;
%* - It may be the case that some values of the categorical varibales are new in the dataset to score and had not been seen
%* in the TRAIN dataset used to fit the model. Those values are treated by PROC SCORE as if they were equal to the reference
%* level as the dummy variable generated by PROC TRANSREG is not present among the model variaales;

%*** Categorical variables INFO read from the &DATACAT or &DATACATREF dataset;
%if %quote(&datacatref) ~= or %quote(&datacat) ~= %then %do;
	%* The model has categorical variables and here we generate the dummy variables needed to apply the model, using PROC TRANSREG;

	%* Formats to use;
	%if %quote(&datacatref) ~= %then %do;
		%* It is assumed that the DATACATREF dataset has only one record per categorical variable;
		data _score_catref_;
			set &datacatref;
		run;
	%end;
	%else %do;
		%* Keep just the FIRST or LAST occurrence of each variable, depending on the value of parameter REF=,
		%* which indicates what level of the categorical variable is the one we should use as reference level;
		%* Note that the FIRST or LAST occurrence are defined by the ordered FORMATTED values (stored in variable FMTVALUE);
		proc sort data=&datacat out=_score_catref_;
			by var fmtvalue;
		run;
		data _score_catref_;
			set _score_catref_;
			by var fmtvalue;
			if &ref..var;
		run;
		%if &log %then %do;
			%put;
			%put SCORE: NOTE - The %upcase(&ref) category of each categorical variable present in dataset %upcase(&datacat);
			%put SCORE: is used as reference level. The order of the categories is defined by the formatted values stored;
			%put SCORE: in variable FMTVALUE present in that dataset.;
		%end;
	%end;
	%* Create a new column that contains both the variable name and its format (the format may be empty);
	%* This is to be able to read the variable name and its format easily into a mcro variable as some
	%* variables may not have any format and matching the names and formats would be tricky;
	data _score_catref_;
		set _score_catref_;
		length format $100;		%* We should reserve character space for the word FORMAT, for the variable name up to 32 characters, and for the format name up to 32 characters;
		%* Note that the FORMAT keyword is added as well to every line because we need to list every format
		%* on a separate line for each variable, because all variables listed in the same line will be applied
		%* the format name given at the end of the line! (e.g. format x y z for. => all variables x y and z will get format FOR.);
		format = catx(' ', 'format', var, fmtname, ';');
	run;
	%let modelvars_class = %MakeListFromVar(_score_catref_, var=var, log=0);
	%let formats = %MakeListFromVar(_score_catref_, var=format, log=0);
	%* Reference levels (note that they are separated by | because the reference levels may have spaces in their values);
	%let reflevels = %MakeListFromVar(_score_catref_, var=fmtvalue, sep=|, log=0);
	%let reflevels_str = "%sysfunc(tranwrd(&reflevels, %quote( | ), %quote(%" %")))";	%* Replace the | separator with double quotes for the ZERO= option below;

	%* SHOW THE PROC TRANSREG STEP IN THE LOG (so that the users can see what exactly we are doing);
	%if %quote(&outfile) = %then %do;
	options mprint;
	%end;
	%else %do;
		%* Save the SAS code to a file;
	/*	filename */
	%end;
	proc transreg data=&data design macro(il=vardummies);
		&idst;
		&formats;
		model class(&modelvars_class / zero=&reflevels_str);
		output out=_score_dummies_;
	run;

	%* Create an index in _SCORE_DUMMIES_ to be able to join with the dataset to score;
	%* This is to avoid sorting the dataset to score which might be problematic if too big...;
	%if %quote(&id) ~= %then %do;
		proc sql;
			create index idx on _score_dummies_ (%MakeList(&id, sep=%quote(,)));
		quit;
		%* Merge with the dummy variables;
		data _score_data_;
			set &data;
			set _score_dummies_(keep=&id &vardummies) key=idx;
			if _IORC_ then _ERROR_ = 0;
			if ~_IORC_;
		run;
	%end;
	%else %do;
		%* Merge with the dummy variables by observation number;
		data _score_data_;
			merge 	&data
					_score_dummies_(keep=&vardummies);
		run;
	%end;
	%if %quote(&outfile) = %then %do;
	options &option_mprint;
	%end;
	
	%let datascore = _score_data_;
%end;
%else %do;
	%* No dummies to create, so the dataset used below in PROC SCORE is directly the input dataset &DATA;
	%let datascore = &data;
%end;

%*************************
%*** 3.- SCORE
%*************************;
%* Define the variables to use for the score computation: only the variables in the model that are also present in the score dataset;
%* IMPORTANT: IT IS THE USERS RESPONSIBILITY TO VERIFY THAT ALL THE NEEDED VARIABLES HAD BEEN CREATED IN THE SCORE DATASET;
%* This step makes it possible to remove variables that are not present in the score dataset, such as dummy variables for
%* categorical levels that do not show up in the score dataset but had shown up in the TRAIN dataset used to fit the model;
%let datavars = %GetVarNames(&datascore);
%let modelvars_use = %KeepInList(&modelvars, &datavars, log=0);	%** THIS TAKES TOO LONG!!;

%* SHOW THE PROC SCORE STEP IN THE LOG (so that the users can see what exactly we are doing);
%if %quote(&outfile) = %then %do;
options mprint;
%end;
%* First rename the name of the variable that will contain the score because the original name stored in the DATAPARAMS
%* dataset may override a variable in the input dataset to score (e.g. when we are generating the score for the very dataset
%* that was used when fitting the model and thus produced the DATAPARAMS dataset! (in fact recall that the name of the score
%* variable is the name of the target variable used when fitting the model);
options varlenchk=nowarn;	%* This is to avoid a WARNING that the variable length changed;
data _score_params_;
	length _NAME_ $32;
	set &dataparams;
	_NAME_ = "&score";
run;
options varlenchk=&option_varlenchk;
proc score 	data=&datascore out=_score_pred_(keep=&id &copy &modelvars_class &modelvars_use &score)
			score=_score_params_ type=parms;
	var &modelvars_use;
run;

%* Compute the predicted probabilities if target is binary as a transformation of the score generated by PROC SCORE;
%if &targetbinary %then %do;
	data _score_pred_;
		format &id &score &response;
		set _score_pred_;
		&response = 1 / (1 + exp(-&score));
	run;
%end;
%if %quote(&outfile) = %then %do;
options &option_mprint;
%end;

%*************************
%*** 4.- PLOTS AND CHECKS
%*************************;
%* Distribution of the score;
%if &plot %then %do;
	title "Distribution of score/response variable (%upcase(&responsevar))";
	proc univariate data=_score_pred_;
		var &responsevar;
		histogram;
	run;
	title;
%end;

%* Check the generated score with a pre-calculated variable;
%if %quote(&datacheck) ~= or %quote(&scorecheck) ~= or %quote(&responsecheck) ~= %then %do;
	%* Check the generated score with a benchmark given either on another dataset or in the same input dataset just scored;
	%if %quote(&datacheck) ~= %then %do;
		%* Read the score to check from the DATACHECK dataset into a temporary dataset;
		%* This is needed in order to safely create the index on the ID variables,
		%* as if an index on the same variables exist, an error is raised;
		data _score_check_(%if %quote(&id) ~= %then %do; index=(idx=(&id) / unique) %end;);
			%if %quote(&outcheck) = %then %do;
			%* We only keep the necessary variables for the score comparison when
			%* the user did NOT request any output dataset to store the compared records (OUTCHECK).
			%* Otherwise, we need to keep all the variables in _SCORE_CHECK_ because below we
			%* create the OUTCHECK dataset with ALL the variables in the DATACHECK dataset;
			keep &id &checkvar;	%* Note that this KEEP does NOT go as part of the data option (although it would make the process faster) because we want any data options passed by the user in DATACHECK to take place;
			%end;
			set &datacheck;
		run;
		%if %quote(&id) = %then %do;
			%put WARNING: No ID variables have been given. Score dataset and check dataset are matched by observation number;
			%put and are assumed to have the same number of observations.;
		%end;
	%end;
	data _score_pred_;
		set _score_pred_;
		%if %quote(&datacheck) ~= %then %do;
		%* Read the score to check from the DATACHECK dataset;
		set _score_check_(keep=&id &checkvar) %if %quote(&id) ~= %then %do; key=idx %end;;
		if _IORC_ ~= 0 then _ERROR_ = 0;
		_incheck = (_IORC_ = 0);
		%end;
		_pred_diff = &responsevar - &checkvar;	%* CHECKVAR is either &SCORECHECK or &RESPONSECHECK;
	run;
	title "Comparison between the computed score/response (%upcase(&responsevar)) and the benchmark score/response (%upcase(&checkvar))";
	title2 "(only matching observations are considered)";
	proc compare base=_score_pred_(where=(_incheck));
		%if %quote(&id) ~= %then %do;
		id &id;
		%end;
		var &responsevar;
		with &checkvar;
	run;
	%if &plot %then %do;
		proc univariate data=_score_pred_(where=(_incheck));
			var _pred_diff;
			histogram;
		run;
		proc sgplot data=_score_pred_(where=(_incheck));
			scatter x=&checkvar y=&responsevar;
		run;
	%end;
	title2;
	title;

	%* Create the output dataset containing the cases that were used for the score comparison;
	%if %quote(&outcheck) ~= and %quote(&datacheck) ~= %then %do;
		data &outcheck;
			format &id &score &response &checkvar _pred_diff;
			set _score_pred_(keep=%if %quote(&id) ~= %then %do; &id %end; &score &response);
			%* Read ALL the variables from the DATACHECK dataset;
			set _score_check_ %if %quote(&id) ~= %then %do; key=idx %end;;
			if _IORC_ ~= 0 then _ERROR_ = 0;
			if _IORC_ = 0;
			_pred_diff = &responsevar - &checkvar;	%* CHECKVAR is either &SCORECHECK or &RESPONSECHECK;
		run;
	%end;
%end;

%*************************
%*** 5.- OUTPUT DATASET AND FINALIZE
%*************************;
%* Create output dataset;
%if %quote(&out) ~= %then %do;
	data &out;
		format &id &score &response;
		set _score_pred_(drop=_incheck _pred_diff &checkvar);
	run;
%end;

%* Delete temporary datasets;
proc datasets nolist;
	delete	_score_catref_
			_score_check_
			_score_data_
			_score_dummies_
			_score_modelvars_
			_score_params_;
	%* Only delete the _SCORE_PRED_ dataset if OUT= is not empty (so that the user has an output);
	%if %quote(&out) ~= %then %do;
	delete _score_pred_;
	%end;
quit;

%* Create global macro variables with the model variables and the model variables used/not used to generate the score;
%global _modelvars_; %let _modelvars_ = &modelvars;
%global _modelvars_used_; %let _modelvars_used_ = &modelvars_use;
%global _modelvars_notused_; %let _modelvars_notused_ = %RemoveFromList(&modelvars, &modelvars_use, log=0);

%if %quote(&_modelvars_notused_) ~= %then %do;
	%put WARNING: The following model variables were not used when calculating the score:;
	%puts(&_modelvars_notused_);
%end;
%else
	%put SCORE: NOTE - All variables in the model have been used to calculate the score.;

%ExecTimeStop;
%ResetSASOptions;

%MEND Score;
