/* MACRO %Score
Created:		19-May-2016
Author:			Daniel Mastropietro
Description:	Score a new dataset based on the estimated parameters of a regression model and
				the definition of the categorical variable levels and formats.

*** Datasets;
%let toscore = scomast.master_ptp01_s2per01;			*** Dataset a scorear con las variables del modelo
%let params = scomast.master_ptp01_s2_r05_est;			*** Dataset con los parametros estimados del modelo de regresion (generado por OUTEST=)
%let datacat = scomast.master_ptp01_s2_r05_refs;		*** Dataset con info de las variables categoricas (ref level, formats, etc.)


targetbinary:	Flag indicating whether the target of the model is binary;
*** Variables;
%let id = A_NroCuenta20 A_PERIODO;
%let copy = MbdEstadoDeLaCuenta;

OTHER MACROS AND MODULES USED IN THIS MACRO:
- %MakeListFromVar
- %KeepInList
- %RemoveFromList

options mprint;
%Score(	toscore,
		dataparams=_PARAMS_, 
		datacatref=,
		datacat=_CATEGORICAL_,
		ref=first,
		targetbinary=1,
		id=A_CueIdCuenta A_PERIODO,
		copy=MbdEstadoDeLaCuenta,
		score=xbeta,
		response=p,
		datacheck=tocheck,
		scorecheck=,				*** THE scorecheck VARIABLE NAME SHOULD BE DIFFERENT FROM THE score VARIABLE NAME!
		responsecheck=z_r05_pd,		*** THE responsecheck VARIABLE NAME SHOULD BE DIFFERENT FROM THE response VARIABLE NAME!
		outcheck=,
		out=toscore_pred,
		outfile=,					*** Quoted name of the file where the SAS code needed to re-create the score is saved.
		log=1);
options nomprint;

Global macro variables are created to store the model variables, the model variables used to generate the score,
and the model variables not used.

REQUIRED PARAMETERS:

- datacatref, datacat:	Datasets containing the categorical variable information with at least the following columns:
						- var:
						- fmtname:
						- fmtvalue:
						The DATACATREF dataset should have only one record per variable, containing the reference
						level used for the variable during the model fit in variable FMTVALUE.

- id:					When checking the score against DATACHECK, the ID variables should be unique,
						as a unique index is created on them in order to match the observations with the
						scored dataset.

- datacheck:			Dataset containing a previously calculated score against which to check
						the score calculated by this macro.
						Cases are matched by the ID variables if given, or by observation number
						if no ID variables are given, in which case it is assumed that both
						datasets have the same number of observations.
						Only matching cases are compared.

- outcheck:				Output dataset containing all the variables in the DATACHECK dataset but just
						the records matching the input dataset that are used for the score comparison.
						This is only created if a DATACHECK dataset is given.
						The OUTCHECK dataset also contains the score or response variable in the input
						dataset and the difference between that score or response variable and the
						scorecheck or responsecheck variable existing in the DATACHECK dataset.
						The variable containing this difference is called _PRED_DIFF.

NOTES:
1.- The variables in the model that are not used when calculating the score are listed at the end of the process
with a WARNING message.

SEE ALSO:
- %FreqMult: to generate the distribution of the categorical variables present in the model that is needed
by this macro 

TODO:
-[DONE] Warn the user when there are less variables used in in PROC SCORE than there exist in the original model.
Show the list of variables removed from the scoring formula.
*/
&rsubmit;
%MACRO Score(	data,
				dataparams=_PARAMS_,
				datacatref=,
				datacat=,
				ref=first,
				targetbinary=1,
				id=,
				copy=,
				score=score,
				response=p,
				datacheck=,
				scorecheck=,
				responsecheck=,
				outcheck=,
				out=,
				outfile=,
				plot=1,
				log=1) / store des="Computes the score of a regression model on a new dataset";

%SetSASOptions;
%ExecTimeStart;

%local datavars;		%* Variables present in the input dataset to score;
%local formats;			%* Formats of variables (containing variable name and format name);
%local idst;			%* ID Statement to use in PROC TRANSREG;
%local modelvars;		%* List of model variables;
%local modelvars_use;	%* List of model variables to use in PROC SCORE;
%local reflevels;		%* List of reference levels of categorical variables;
%local reflevels_str;	%* Reference levels string to use in the ZERO= option of the CLASS statement of PROC TRANSREG;
%local checkvar;		%* Variable name in the DATACHECK dataset containing the score to check (either &SCORECHECK or &RESPONSECHECK);
%local vardummies;		%* List of dummy variables generated by PROC TRANSREG;

%* Macro variables that store current option settings;
%local option_mprint;
%local option_varlenchk;

/*------------------------------------ Parse input parameters -------------------------------*/
%*** ID=;
%if %quote(&id) ~= %then
	%let idst = id &id;

%*** TARGETTYPE=;
%if &targetbinary %then %do;
	%let responsevar = &response;
	%let checkvar = &responsecheck;
%end;
%else %do;
	%let responsevar = &score;
	%let checkvar = &scorecheck;
%end;
/*------------------------------------ Parse input parameters -------------------------------*/


%* Store current options;
%let option_mprint = %sysfunc(getoption(mprint));
%let option_varlenchk = %sysfunc(getoption(varlenchk));


%*************************
%*** 1.- Data prep
%*************************;
%* A) The variable that will contain the score when PROC SCORE is applied is defined in the input DATAPARAMS dataset (&SCORE);
%* B) The list of model variables is stored in a macro variable;

%* A) Set _NAME_ = "&score" in the DATAPARAMS;
options varlenchk=nowarn;
data _score_params_;
	length _NAME_ $10;
	set &dataparams;
	_NAME_ = "&score";
run;
options varlenchk=&option_varlenchk;

%* B) Lista of model variables taken form the PARAMS= dataset;
proc transpose data=_score_params_ out=_score_modelvars_ name=var;
run;
data _score_modelvars_;
	set _score_modelvars_;
	where not missing(&score) and var not in ("Intercept", "_LNLIKE_");
run;
%let modelvars = %MakeListFromVar(_score_modelvars_, var=var, log=0);


%*************************
%*** 2.- Dummy variables
%*************************;
%* Dummy variables for the categorical variables;
%* The generated dummy variables are saved into macro variable &VARDUMMIES;
%* NOTES:
%* - We use the ZERO="<var1-ref-level>" "<var2-ref-level>" ... in the CLASS statement in order to define the reference level
%* of each categorical variable;
%* Note that we should NOT use ZERO=FIRST or ZERO=LAST because such level (the first or the last one) is determined by the
%* categorical values present in the dataset to score...!;
%* - The reference value for formatted variables should be set to the formatted value, NOT the unformatted one;
%* - The reference value for numeric unformatted variables should still be enclosed in quotes;
%* - It may be the case that some values of the categorical varibales are new in the dataset to score and had not been seen
%* in the TRAIN dataset used to fit the model. Those values are treated by PROC SCORE as if they were equal to the reference
%* level as the dummy variable generated by PROC TRANSREG is not present among the model variaales;

%*** Categorical variables INFO read from the &DATACAT or &DATACATREF dataset;
%if %quote(&datacatref) ~= or %quote(&datacat) ~= %then %do;
	%* The model has categorical variables and here we generate the dummy variables needed to apply the model, using PROC TRANSREG;

	%* Formats to use;
	%if %quote(&datacatref) ~= %then %do;
		%* It is assumed that the DATACATREF dataset has only one record per categorical variable;
		data _score_catref_;
			set &datacatref;
		run;
	%end;
	%else %do;
		%* Keep just the FIRST or LAST occurrence of each variable, depending on the value of parameter REF=,
		%* which indicates what level of the categorical variable is the one we should use as reference level;
		%* Note that the FIRST or LAST occurrence are defined by the ordered FORMATTED values (stored in variable FMTVALUE);
		proc sort data=&datacat out=_score_catref_;
			by var fmtvalue;
		run;
		data _score_catref_;
			set _score_catref_;
			by var fmtvalue;
			if &ref..var;
		run;
		%if &log %then %do;
			%put;
			%put SCORE: NOTE - The %upcase(&ref) category of each categorical variable present in dataset %upcase(&datacat);
			%put SCORE: is used as reference level. The order of the categories is defined by the formatted values stored;
			%put SCORE: in variable FMTVALUE present in that dataset.;
		%end;
	%end;
	%* Create a new column that contains both the variable name and its format (the format may be empty);
	%* This is to be able to read the variable name and its format easily into a mcro variable as some
	%* variables may not have any format and matching the names and formats would be tricky;
	data _score_catref_;
		set _score_catref_;
		length format $100;		%* We should reserve character space for the word FORMAT, for the variable name up to 32 characters, and for the format name up to 32 characters;
		%* Note that the FORMAT keyword is added as well to every line because we need to list every format
		%* on a separate line for each variable, because all variables listed in the same line will be applied
		%* the format name given at the end of the line! (e.g. format x y z for. => all variables x y and z will get format FOR.);
		format = catx(' ', 'format', var, fmtname, ';');
	run;
	%let modelvars_class = %MakeListFromVar(_score_catref_, var=var, log=0);
	%let formats = %MakeListFromVar(_score_catref_, var=format, log=0);
	%* Reference levels (note that they are separated by | because the reference levels may have spaces in their values);
	%let reflevels = %MakeListFromVar(_score_catref_, var=fmtvalue, sep=|, log=0);
	%let reflevels_str = "%sysfunc(tranwrd(&reflevels, %quote( | ), %quote(%" %")))";	%* Replace the | separator with double quotes for the ZERO= option below;

	%* SHOW THE PROC TRANSREG STEP IN THE LOG (so that the users can see what exactly we are doing);
	%if %quote(&outfile) = %then %do;
	options mprint;
	%end;
	%else %do;
		%* Save the SAS code to a file;
	/*	filename */
	%end;
	proc transreg data=&data design macro(il=vardummies);
		&idst;
		&formats;
		model class(&modelvars_class / zero=&reflevels_str);
		output out=_score_dummies_;
	run;
	%if %quote(&outfile) = %then %do;
	options &option_mprint;
	%end;

	%* Create an index in _SCORE_DUMMIES_ to be able to join with the dataset to score;
	%* This is to avoid sorting the dataset to score which might be problematic if too big...;
	%if %quote(&id) ~= %then %do;
		proc sql;
			create index idx on _score_dummies_ (%MakeList(&id, sep=%quote(,)));
		quit;
		%* Merge with the dummy variables;
		data _score_data_;
			set &data;
			set _score_dummies_(keep=&id &vardummies) key=idx;
			if _IORC_ then _ERROR_ = 0;
			if ~_IORC_;
		run;
	%end;
	%else %do;
		%* Merge with the dummy variables by observation number;
		data _score_data_;
			merge 	&data
					_score_dummies_(keep=&vardummies);
		run;
	%end;
	
	%let datascore = _score_data_;
%end;
%else %do;
	%* No dummies to create, so the dataset used below in PROC SCORE is directly the input dataset &DATA;
	%let datascore = &data;
%end;

%*************************
%*** 3.- SCORE
%*************************;
%* Define the variables to use for the score computation: only the variables in the model that are also present in the score dataset;
%* IMPORTANT: IT IS THE USERS RESPONSIBILITY TO VERIFY THAT ALL THE NEEDED VARIABLES HAD BEEN CREATED IN THE SCORE DATASET;
%* This step makes it possible to remove variables that are not present in the score dataset, such as dummy variables for
%* categorical levels that do not show up in the score dataset but had shown up in the TRAIN dataset used to fit the model;
%let datavars = %GetVarNames(&datascore);
%let modelvars_use = %KeepInList(&modelvars, &datavars, log=0);	%** THIS TAKES TOO LONG!!;

%* SHOW THE PROC SCORE STEP IN THE LOG (so that the users can see what exactly we are doing);
%if %quote(&outfile) = %then %do;
options mprint;
%end;
proc score 	data=&datascore out=_score_pred_(keep=&id &copy &modelvars_class &modelvars_use &score)
			score=_score_params_ type=parms;
	var &modelvars_use;
run;
%if %quote(&outfile) = %then %do;
options &option_mprint;
%end;

%* Compute the predicted probabilities if target is binary as a transformation of the score generated by PROC SCORE;
%if &targetbinary %then %do;
	data _score_pred_;
		set _score_pred_;
		&response = 1 / (1 + exp(-&score));
	run;
%end;

%* Distribution of the score;
%if &plot %then %do;
	title "Distribution of score/response variable (%upcase(&responsevar))";
	proc univariate data=_score_pred_;
		var &responsevar;
		histogram;
	run;
	title;
%end;

%* Check the generated score with a pre-calculated variable;
%if %quote(&datacheck) ~= or %quote(&scorecheck) ~= or %quote(&responsecheck) ~= %then %do;
	%* Check the generated score with a benchmark given either on another dataset or in the same input dataset just scored;
	%if %quote(&datacheck) ~= %then %do;
		%* Read the score to check from the DATACHECK dataset into a temporary dataset;
		%* This is needed in order to safely create the index on the ID variables,
		%* as if an index on the same variables exist, an error is raised;
		data _score_check_(%if %quote(&id) ~= %then %do; index=(idx=(&id) / unique) %end;);
			%if %quote(&outcheck) = %then %do;
			%* We only keep the necessary variables for the score comparison when
			%* the user did NOT request any output dataset to store the compared records (OUTCHECK).
			%* Otherwise, we need to keep all the variables in _SCORE_CHECK_ because below we
			%* create the OUTCHECK dataset with ALL the variables in the DATACHECK dataset;
			keep &id &checkvar;	%* Note that this KEEP does NOT go as part of the data option (although it would make the process faster) because we want any data options passed by the user in DATACHECK to take place;
			%end;
			set &datacheck;
		run;
		%if %quote(&id) = %then %do;
			%put WARNING: No ID variables have been given. Score dataset and check dataset are matched by observation number;
			%put and are assumed to have the same number of observations.;
		%end;
	%end;
	data _score_pred_;
		set _score_pred_;
		%if %quote(&datacheck) ~= %then %do;
		%* Read the score to check from the DATACHECK dataset;
		set _score_check_(keep=&id &checkvar) %if %quote(&id) ~= %then %do; key=idx %end;;
		if _IORC_ ~= 0 then _ERROR_ = 0;
		if _IORC_ = 0;
		%end;
		_pred_diff = &responsevar - &checkvar;	%* CHECKVAR is either &SCORECHECK or &RESPONSECHECK;
	run;
	title "Comparison between the computed score/response (%upcase(&responsevar)) and the benchmark score/response (%upcase(&checkvar))";
	proc compare base=_score_pred_;
		%if %quote(&id) ~= %then %do;
		id &id;
		%end;
		var &responsevar;
		with &checkvar;
	run;
	%if &plot %then %do;
		proc univariate data=_score_pred_;
			var _pred_diff;
			histogram;
		run;
		proc sgplot data=_score_pred_;
			scatter x=&checkvar y=&responsevar;
		run;
	%end;
	title;

	%* Create the output dataset containing the cases that were used for the score comparison;
	%if %quote(&outcheck) ~= and %quote(&datacheck) ~= %then %do;
		data &outcheck;
			format &id &responsevar &checkvar _pred_diff;
			set _score_pred_(%if %quote(&id) ~= %then %do; keep=&id &responsevar %end;);
			%* Read ALL the variables from the DATACHECK dataset;
			set _score_check_ %if %quote(&id) ~= %then %do; key=idx %end;;
			if _IORC_ ~= 0 then _ERROR_ = 0;
			if _IORC_ = 0;
			_pred_diff = &responsevar - &checkvar;	%* CHECKVAR is either &SCORECHECK or &RESPONSECHECK;
		run;
	%end;
%end;

%* Create output dataset;
%if %quote(&out) ~= %then %do;
	data &out;
		set _score_pred_;
	run;
%end;

%* Delete temporary datasets;
proc datasets nolist;
	delete	_score_catref_
			_score_check_
			_score_data_
			_score_dummies_
			_score_modelvars_
			_score_params_
			_score_pred_;
quit;

%* Create global macro variables with the model variables and the model variables used/not used to generate the score;
%global _modelvars_; %let _modelvars_ = &modelvars;
%global _modelvars_used_; %let _modelvars_used_ = &modelvars_use;
%global _modelvars_notused_; %let _modelvars_notused_ = %RemoveFromList(&modelvars, &modelvars_use, log=0);

%if %quote(&_modelvars_notused_) ~= %then %do;
	%put WARNING: The following model variables were not used when calculating the score:;
	%puts(&_modelvars_notused_);
%end;
%else
	%put SCORE: NOTE - All variables in the model have been used to calculate the score.;

%ExecTimeStop;
%ResetSASOptions;

%MEND Score;
