/* MACRO %FreqMult
Version: 		2.01
Author: 		Daniel Mastropietro
Created: 		15-Oct-2004
Modified: 		05-Aug-2015 (previous: 07-Sep-06)
SAS Version:	9.4

DESCRIPTION:
This macro computes the frequencies of a list of variables (using PROC FREQ) and stores the
results in an output dataset containing the frequencies of all the variables.
The output can be either long (i.e. one row per value of the variables) or wide (i.e. one row
per variable).
The analyzed variables can be either character, numeric or mixed.
By default missing values are NOT treated as a valid value in the computations of the percents.

USAGE:
%FreqMult(
	data,					*** Input dataset.
	target=,				*** Target variable to cross the variables VAR with.
	var=_ALL_,				*** List of variables to analyze.
	by=,					*** List of BY variables.
	format=,				*** Format to use for each variable listed in VAR.
	out=_FreqMult_,	    	*** Output dataset containing the frequencies.
	options=,				*** Options for the TABLES statement.
	missing=0,				*** Missing values are valid values?
	transpose=0,			*** Transpose output dataset so that there is one record per variable?
	maxlengthvalues=255,	*** Initial length to assign to the VALUES column holding the values taken by the variable
							*** in the transposed output case.
	notes=1,				*** Show SAS notes in the log?
	log=1);					*** Show messages in the log?

REQUIRED PARAMETERS:
- data:			Input dataset. Data options can be specified as in a data= SAS option.

OPTIONAL PARAMETERS:
- target:			Target variable to cross the variables VAR with.

- var:				Blank-separated list of variables to analyze.

- by:				List of BY variables, by which the frequency analysis is done.

- format:			Format to use for each analysis variable listed in VAR. This statement can be
					used to define groups.
					Just the format name needs to be specified, and only one format is allowed, which
					applies to ALL the variables listed in VAR=.

- out:				Output dataset, containing the frequencies of each variable listed in 'var'.
					The dataset is sorted by analyzed variable, BY variables and target variable.
					Note that this is NOT the usual order used by other SAS procedures which first sort
					the output data by the BY variables, but in this case it is believed that it is of
					greater importance to compare BY groups within each analyzed variable.
					Despite of this sorting, the BY variables are always placed at the initial columns.
					Data options can be specified as in a data= SAS option.
					The dataset has the following columns:
					LONG FORMAT (TRANSPOSE=0):
					- <by-variables> if any.
					- var:			Variable name corresponding to the frequencies shown.
					- type:			Variable type ("character" or "numeric").
					- value(*):		Value taken by the variable when all variables are of the same type.
					- numvalue(*): 	Values taken by the variable, if numeric.
					- charvalue(*):	Values taken by the variable, if character.
					- <target variable> if any.
					- nvalues: 		Number of different values taken by the variable.
					- nobs:			Number of observations used in computations.
					- count: 		COUNT variable generated by PROC FREQ.
					- percent: 		PERCENT variable generated by PROC FREQ.
					(*) If all the variables are character or all the variables are numeric,
					then only the VALUE column is present. Otherwise, the columns NUMVALUE and
					CHARVALUE are present and VALUE is not.

					WIDE FORMAT (TRANSPOSE=1):
					- var:			Variable name corresponding to the frequencies shown.
					- type:			Variable type ("character" or "numeric").
					- values:		List of values taken by the variable separated by columns.
					- <target variable> if any.

					default: _FreqMult_

- options:			Options for the TABLES statement.
					Note: If statistics options (such as Chisq) are specified, they are NOT
					generated in the output dataset, because the output dataset has only the
					frequency distribution for each variable.

- missing:			Whether the missing values should be considered as valid variable values.
					Possible values: 0 => Missing values are NOT valid values
									 1 => Missing values are valid values
					default: 0

- transpose			Transpose output dataset so that there is one record per variable?
					default: 0

- maxlengthvalues 	Initial length to assign to the VALUES column holding the values taken by the
					variable so that no value is lost.
					This parameter can be increased in order to avoid truncation in the output values
					if the number of different values taken by a variable is too large.
					This parameter is used only when TRANSPOSE=1.
					Possible values: any positive integer value <= 32,767
					default: 255

- notes:			Indicates whether to show SAS notes in the log.
					The notes are shown only for the PROC MEANS step.
					Possible values: 0 => No, 1 => Yes.
					default: 0

- log:				Show messages in the log?
					Possible values: 0 => No, 1 => Yes
					default: 1

OTHER MACROS AND MODULES USED IN THIS MACRO:
- %Callmacro
- %GetDataOptions
- %Getnobs
- %GetLibraryName
- %GetNroElements
- %GetStat
- %GetVarList
- %RemoveRepeated
- %ResetSASOptions
- %SetSASOptions

SEE ALSO:
- %Freq

EXAMPLES:
1.- %FreqMult(test, var=xnum ynum zchar, out=test_freq);
This computes the frequencies of the values taken by the variables XNUM, YNUM and ZCHAR and
stores the result in dataset TEST_FREQ.
Assuming that variables XNUM and YNUM are numeric and that variable ZCHAR is character, two
columns are created in dataset TEST_FREQ containing the values taken by the variables:
NUMVALUE, for the values taken by XNUM and YNUM, and CHARVALUE, for the values taken by ZCHAR.
;
2.- %FreqMult(test, var=xnum ynum zchar, out=test_freq(keep=var numvalue charvalue percent), missing=1);
Same as above, but missing values are now considered as valid variable values.
In addition only the variables VAR, NUMVALUE, CHARVALUE and COUNT are kept in the output
dataset.
*/

/* PENDIENTE:
- (21/3/05) Agregar un parametro OUTSTAT= que genere un dataset con los estadisticos
solicitados en el parametro OPTIONS= (como Chisq por ej.), ya que en el OUT= dataset
se genera la distibucion de cada variable, no los estadisticos. Para generar el OUTSTAT=
dataset hay que reformular la aplicacion del PROC FREQ para cada variable, ya que es
necesario aplicarlo a cada una de las variables por separado ya que el OUTPUT statement
(que es el que debe usarse para guardar la informacion de los estadisticos solicitados)
aplica solamente a la ultima variable analizada con el TABLES statement.
*/
&rsubmit;
%MACRO FreqMult(data,
				target=,
				var=_ALL_,
				by=,
				format=,
				out=_FreqMult_,
				options=,
				missing=0,
				transpose=0,
				maxlengthvalues=255,
				notes=0,
				log=1,
				help=0) / store des="Creates a dataset with the frequencies of a set of variables";

%* These variables are declared here because they are needed before the call to %CheckInputParameters;
%local by_orig;			%* Temporal list of by variables including any DESCENDING keyword;
%local byvarlist;		%* List of by variables without any DESCENDING keyword;
%local data_options;
%local error;

/*----- Macro to display usage -----*/
%MACRO ShowMacroCall;
	%put;
	%put FREQMULT: The macro call is as follows:;
	%put;
	%put %nrstr(%FreqMult%();
	%put data , (REQUIRED) %quote(      *** Input dataset.);
	%put target= , %quote(              *** Target dichotomous variables.);
	%put var=_ALL_ , %quote(            *** Analysis variables.);
	%put by= , %quote(                  *** List of BY variables.);
	%put format= , %quote(              *** Format to be used for selected analysis variables.);
	%put out=_FreqMult_ , %quote(       *** Output dataset containing the values taken by each analysis);
	%put %quote(                        *** variables, its counts and its frequencies.);
	%put %quote(transpose=0 ,           *** Transpose output dataset so that there is one record per variable?);
	%put %quote(maxlengthvalues=255 ,   *** Initial length to assign to the VALUES column holding the values taken by the variable);
	%put %quote(                        *** in the transposed output case.);
	%put options= ,	%quote(             *** Options for the TABLES statement in PROC FREQ.);
	%put missing=0 , %quote(            *** Should missing values be considered as valid values?);
	%put notes=1 , %quote(              *** Show SAS notes in the log?);
	%put log=1) %quote(                 *** Show messages in the log?);
%MEND ShowMacroCall;
/*----- Macro to display usage -----*/

%if &help %then %do;
	%ShowMacroCall;
%end;
%else %do;
%* Checking existence of input datasets and existence of variables in datasets;
%let error = 0;
%let data_options = %GetDataOptions(%quote(&data));
%if ~%index(%quote(%upcase(&data_options)), RENAME) %then %do;
	%* The check is done only if there is no RENAME option in the specification of the dataset;
	%if %quote(&by) ~= %then %do;
		%let by_orig = &by;
		%* Remove from the list of BY variables the keyword DESCENDING in case it exists,
		%* otherwise the macro %CheckInputParameters will report the non-existence of variable DESCENDING...;
		%let by = %RemoveFromList(%quote(&by), descending, log=0);
	%end;
	%if ~%CheckInputParameters(data=&data , var=&var , check=target by, macro=FREQMULT) %then %do;
		%ShowMacroCall;
		%let error = 1;
	%end;
	%* Re-establish the content of the BY parameter, in case the DESCENDING option existed, which was removed above
	%* before calling %CheckInputParameters;
	%else %do;
		%let byvarlist = &by;
		%let by = &by_orig;
	%end;
%end;
%if ~&error %then %do;
/************************************* MACRO STARTS ******************************************/
%local i;
%local nro_vars nvalues vari vartype vartypei;
%local nobs nvar;
%local maxlength;			%* Maximum length of analyzed variable names;
%local byst;
/*%local nro_byvars;		%* Descomentar si creo un indice en el PROC SORT del comienzo del codigo; */
%local bothTypes type;
%local out_name library;	%* Name of output dataset and library where it is created.
							%* The library is necessary because the output dataset
							%* is deleted with a PROC DATASETS at the beginning and
							%* this gives an error if I do not parse the library name;
%local missingopt;			%* Option in the tables statement of the PROC FREQ stating whether
							%* missing values should be considered in the computations;
%local varorder;
%local varlenchk_opt;

%SetSASOptions(notes=&notes);

%* Show input parameters;
%if &log %then %do;
	%put;
	%put FREQMULT: Macro starts;
	%put;
	%put FREQMULT: Input parameters:;
	%put FREQMULT: - Input dataset = %quote(    &data);
	%put FREQMULT: - target = %quote(           &target);
	%put FREQMULT: - var = %quote(              &var);
    %put FREQMULT: - by = %quote(               &by);
	%put FREQMULT: - format = %quote(           &format);
	%put FREQMULT: - out = %quote(              &out);
	%put FREQMULT: - options = %quote(          &options);
	%put FREQMULT: - missing = %quote(          &missing);
	%put FREQMULT: - transpose = %quote(        &transpose);
	%put FREQMULT: - maxlengthvalues = %quote(  &maxlengthvalues);
	%put FREQMULT: - notes = %quote(            &notes);
	%put FREQMULT: - log = %quote(              &log);
	%put;
%end;

/*----- Parsing input parameters -----*/
%*** DATA;
%if &log %then %do;
	%put FREQMULT: Reading input dataset...;
	%put;
%end;

%*** BY=;
%let byst = ;
%if %quote(&by) ~= %then %do;
/*	%let nro_byvars = %GetNroElements(%quote(&by));		* Descomentar si creo el indice; */
	proc sort data=&data out=_FreqMult_data_(keep=&var &byvarlist &target
	/*  Creacion de indice: (14/06/06) Por ahora comento la creacion del indice porque parece que tarda mas usar indice que no usarlo.
		Al menos en el ejemplo de una sola BY variable que estuve probando.
		Por otra parte, la forma de usar el indice es NO ORDENAR POR LAS BY VARIABLES sino simplemente crear
		el indice a partir de las BY variables. Si ordeno por las BY variables, el indice no es usado en BY processing
		aun cuando al ordenar cree el indice.
											 %if &nro_byvars = 1 %then %do;
												index=(&by) %end;
											%else %do;
												index=(byvar=(&by)) %end; */	);
		by &by;
	run;
	%let byst = by &by;
%end;
%else %do;
	data _FreqMult_data_(keep=&var &target);
		set &data;
	run;
%end;

%*** VAR=;
%let var = %GetVarList(_FreqMult_data_, var=&var, log=0);
%let nro_vars = %GetNroElements(&var);

%*** OUT=;
%if %quote(&out) ~= %then %do;
	%let out_name = %scan(&out, 1, '(');
	%let library = %GetLibraryName(&out_name);
	%if %index(&out_name, .) > 0 %then
		%let out_name = %scan(&out_name, 2, '.');
%end;
%* Delete dataset used as base dataset in PROC APPEND when transpose=1 in case it exists;
proc datasets nolist;
	delete _FreqMult_out_;
quit;

%*** MISSING=;
%let missingopt = ;
%if &missing %then
	%let missingopt = missing;
/*------------------------------------*/

%* PROC CONTENTS of variables to get their lengths;
proc contents data=_FreqMult_data_ out=_FreqMult_pc_ noprint;
run;
%* Length of numeric variables;
%GetStat(_FreqMult_pc_(where=(type=1)), var=length, stat=max, name=_numlength_max_, log=0);
%* Length of character variables;
%GetStat(_FreqMult_pc_(where=(type=2)), var=length, stat=max, name=_charlength_max_, log=0);

%let maxlength = 0;
%let vartype = ;
proc freq data=_FreqMult_data_ noprint;
	%do i = 1 %to &nro_vars;
		%let vari = %scan(&var, &i, ' ');
		%* Update maximum length of variable name;
		%let maxlength = %sysfunc(max(&maxlength, %length(&vari)));
		%* Read variable type (character or numeric);
		%let vartypei = %upcase(%GetVarType(_FreqMult_data_, &vari));
		%let vartype = &vartype &vartypei;
		%if &vartypei = C %then
			%let type = char;
		%else
			%let type = num;

		%if %quote(&format) ~= %then %do;
		format &vari &format;
		%end;

		&byst;

		%if %quote(&target) ~= %then %do;
		tables &vari*&target / &options &missingopt out=_FreqMult_out&i(rename=(&vari=&type.value));
		%end;
		%else %do;
		tables &vari / &options &missingopt out=_FreqMult_out&i(rename=(&vari=&type.value));
		%end;

		%if &log %then
			%put FREQMULT: Computing frequencies of variable %upcase(&vari)...;
	%end;
run;

%* Check if variables of both types (i.e. character and numeric) where analyzed. This affects
%* the name of the variable containing the freq values and whether it is necessary (in case
%* both types are analyzed) to add a variable (named either CHARVALUE or NUMVALUE)
%* containing missing values to the dataset created for each analyzed variable, so that the
%* PROC APPEND that generates the output dataset does not give an error;
%if %GetNroElements(%RemoveRepeated(&vartype, log=0)) = 1 %then
	%let bothTypes = 0;
%else
	%let bothTypes = 1;

%* Create output dataset;
%if &log %then %do;
	%put;
	%put FREQMULT: Appending tables into %upcase(&out)...;
%end;
proc datasets library=&library nolist;
	delete &out_name;
quit;
%do i = 1 %to &nro_vars;
	%let vari = %scan(&var, &i, ' ');
	%* Number of different values found in varible &var;
	%Callmacro(getnobs, _FreqMult_out&i return=1, nvalues);
	%* Number of observations used in computations (i.e. sum of COUNT);
	proc means data=_FreqMult_out&i sum noprint;
		%if ~&missing %then %do;
		where percent ~= .;		%* Exclude the missing values from the count of nro. of obs
								%* This assumes that the variable PERCENT is kept in the output dataset
								%* (which should usually or always be the case). I do not use
								%* the value of the variable because I need to check again for
								%* the TYPE of the variable (C or N) since the name of the
								%* variable containing the values taken by the variable analyzed
								%* is &type.value;
		%end;
		var count;
		output out=_FreqMult_means_(drop=_TYPE_ _FREQ_) sum=nobs;
	run;
	data _FreqMult_out&i;
		%* Define the order of the variables and their lengths;
		format &byvarlist var type;
		length type $10;
		%if &bothTypes %then %do;
		format numvalue best12.;	%* This format is to avoid showing ** when the format is not long enough (eg 2. instead of 8.);
		format charvalue nvalues nobs;
		%* Define the lengths of numeric and character variables to avoid truncation;
		length numvalue &_numlength_max_;
		length charvalue $&_charlength_max_;
		%end;
		%else %do;
			%if %scan(&vartype, &i, ' ') = C %then %do;
			length value $&_charlength_max_;		%* This is to avoid the message VARIABLE VALUE HAS DIFFERENT LENGTHS ON BASE AND DATA FILE in the PROC APPEND below;
			format value $&_charlength_max_..;
			%end;
			%else %do;
			length value &_numlength_max_;			%* This is to avoid the message VARIABLE VALUE HAS DIFFERENT LENGTHS ON BASE AND DATA FILE in the PROC APPEND below;
			format value best12.;	%* This format is to avoid showing ** when the format is not long enough (eg 2. instead of 8.);
			%end;

		%end;
		format &target nvalues nobs;

		set _FreqMult_out&i
			(%if ~&bothTypes %then %do; rename=(&type.value=value) %end;);
			%** Note that in case only one type of variable is analyzed (i.e. character or
			%** numeric), the name used for the variable containing the freq values
			%** is VALUE (not CHARVALUE or NUMVALUE as is the case when both types are
			%** present);
		if _N_ = 1 then set _FreqMult_means_;
		format percent 7.2;
		length var $&maxlength;
		var = "&vari";
		%if %scan(&vartype, &i, ' ') = C %then %do;
			type = "character";
		%end;
		%else %do;
			type = "numeric";
		%end;
		%* Number of different values found for current variable;
		nvalues = &nvalues;
		label 	var = "Variable Name"
				type = "Variable Type"
				%if &bothTypes %then %do;
				numvalue = "Value taken by numeric variables"
				charvalue = "Value taken by character variables"
				%end;
				%if %quote(&target) ~= %then %do;
				nvalues = "Number of Combinations"
				%end;
				%else %do;
				nvalues = "Number of Different Values"
				%end;
				nobs = "Total Number of Valid Observations";
	run;

	%*** Append the results of the current variable to the output dataset with al the analyzed variables;
	%* NOTE: The output dataset is sorted by VAR and then by the BY variables;
	proc append base=_FreqMult_out_ data=_FreqMult_out&i force;
	run;
%end;

%*** Create the output dataset and transpose the data if requested;
%if &transpose %then %do;
	%* Sort by VAR, <BY variables>, <TARGET variable>, which is needed for the transpose process;
	proc sort data=_FreqMult_out_;
		by var &by &target;
	run;
	%* Create a single column containing all the frequency values;
	data _FreqMult_out_;
		keep &byvarlist var type values &target;
		format &byvarlist var type values &target;
		set _FreqMult_out_(keep=&byvarlist var type &target %if &bothTypes %then %do; charvalue numvalue %end; %else %do; value %end;) end=lastobs;
		by var &by &target;
		length valuec values $&maxlengthvalues;	%* valuec stores the value of the variable as character, variable values stores all the values taken by the variable;
		retain values;				%* This variable contains all the concatenated values taken by each variable;
		retain maxlengthvalues;		%* This variable is used to measure the maximum length of the VALUES variable;

		%* Read the current variable value (depending on the value of &bothTypes this is read from different variables);
		%if &bothTypes %then %do;
		if type = "character" then
			if missing(charvalue) then
				valuec = "<Miss>";
			else
				valuec = charvalue;
		else
			%* Store the numeric value as character;
			if missing(numvalue) then
				valuec = "<Miss>";
			else
				valuec = trim(left(put(numvalue, best12.)));
		%end;
		%else %do;
		if missing(value) then
			valuec = "<Miss>";
		else
			valuec = trim(left(put(value, best12.)));
		%end;

		%* Start a new group;
		if %MakeList(var &byvarlist &target, prefix=First., sep=or) then
			values = valuec;
		else
			values = catx(", ", values, valuec);

		%* Output the last occurrence of the current group;
		if %MakeList(var &byvarlist &target, prefix=Last., sep=or) then do;
			%* Update the macro variable containing the maximum length of the VALUES variable (in order to shorten it as much as possible at the end);
			maxlengthvalues = max(maxlengthvalues, length(values));	%* Note that the LENGTH() function computes the length of the variable value without taking into account the blanks at the end;
			output;
		end;
		if lastobs then
			%* Store the length of variable VALUES to the ;
			call symput ('maxlengthvalues', maxlengthvalues);
	run;

	%*** Create the final output dataset ad update the length of the VALUES variable to its shortest possible length (based on the actual used space);
	%GetVarOrder(_FreqMult_out_, varorder);
	%let varlenchk_opt = %sysfunc(getoption(varlenchk));
	%* Set the option that checks variable length change to no-warning, o.w. there is a warning that data may have been truncated;
	options varlenchk=nowarn;
	data &out;
		format &varorder;
		length values $&maxlengthvalues;	%* Shorten the length of the VALUES variable as much as possible based on the data;
		set _FreqMult_out_;
	run;
	options varlenchk=&varlenchk_opt;
%end;
%else %do;
	%* Sort by VAR, <BY variables>, value of variable, <TARGET variable>, and create the final output datset;
	%* Note that the value of the variable comes before the TARGET variable in the sort order because this is the way
	%* it is sorted by PROC FREQ of <var>*<target>;
	proc sort data=_FreqMult_out_ out=&out;
		by var &by %if &bothTypes %then %do; charvalue numvalue %end; %else %do; value %end; &target;
	run;
%end;

%if &log %then %do;
	%Callmacro(getnobs, &out return=1, nobs nvar);
	%put FREQMULT: Dataset %upcase(&out) created with &nobs observations and &nvar variables.;
%end;

%* Delete global macro variables created by %GetStat;
%symdel _numlength_max_ _charlength_max_;
quit;	%* To avoid problems with %symdel;

proc datasets nolist;
	%do i = 1 %to &nro_vars;
		delete _FreqMult_out&i;
	%end;
	delete 	_FreqMult_data_
			_FreqMult_Means_
			_FreqMult_pc_
			_FreqMult_out_;
quit;

%if &log %then %do;
	%put;
	%put FREQMULT: Macro ends;
	%put;
%end;

%ResetSASOptions;

%end;	%* %if ~&error;

%end;	%* %if &help;
%MEND FreqMult;



/* Tests for version 1.06 created on 04-Aug-2015 */
/*
*** Tests;
data _fm_test_;
	length c $10;
	c = "test"; x = 2; y = 3.5; output;
	c = "test"; x = 20; y = -3.5; output;
	c = "daniel"; x = 8; y = 3.5; output;
	c = "test"; x = -2; y = 35.8E-9; output;
	c = "daniel"; x = 8; y = -9999; output;
	c = "daniel"; x = 8; y = .; output;
	c = ""; x = 8; y = 33; output;
run;

*options mprint;
* NOTE: On purpose list variables in non-alphabetical order to check that the output is alphabetically sorted and that the macro does not break;
title "Test 1A: Three mixed variables";
%FreqMult(_fm_test_, var=x y c, out=_fm_test_freq); proc print data=_fm_test_freq; run;
title "Test 2A: Two numeric variables, by character variable";
%FreqMult(_fm_test_, var=y x, by=c, out=_fm_test_freq); proc print data=_fm_test_freq; run;
title "Test 3A: Two mixed variables, by numeric variable";
%FreqMult(_fm_test_, var=c y, by=x, out=_fm_test_freq, missing=1); proc print data=_fm_test_freq; run;
title "Test 4A: One numeric variable, by descending variable";
%FreqMult(_fm_test_, var=y, by=c descending x, out=_fm_test_freq, missing=1); proc print data=_fm_test_freq; run;
title "Test 5A: Target variable";
%FreqMult(_fm_test_, target=c, var=x y, out=_fm_test_freq); proc print data=_fm_test_freq; run;

* Transpose = 1;
title "Test 1B: Three mixed variables (transposed)";
%FreqMult(_fm_test_, var=x y c, out=_fm_test_freq, transpose=1); proc print data=_fm_test_freq; run;
title "Test 2B: Two numeric variables, by character variable (transposed)";
%FreqMult(_fm_test_, var=y x, by=c, out=_fm_test_freq, transpose=1); proc print data=_fm_test_freq; run;
title "Test 3B: Two mixed variables, by numeric variable (transposed)";
%FreqMult(_fm_test_, var=c y, by=x, out=_fm_test_freq, missing=1, transpose=1); proc print data=_fm_test_freq; run;
title "Test 4B: One numeric variable, by descending variable (transposed)";
%FreqMult(_fm_test_, var=y, by=c descending x, out=_fm_test_freq, missing=1, transpose=1); proc print data=_fm_test_freq; run;
title "Test 5B: Target variable";
%FreqMult(_fm_test_, target=c, var=x y, out=_fm_test_freq, transpose=1); proc print data=_fm_test_freq; run;
options nomprint;
title;

proc datasets nolist;
	delete _fm_test_ _fm_test_freq;
quit;
*/
