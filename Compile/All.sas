/* MACRO %All
Version: 1.08
Author: Daniel Mastropietro
Created: 30-Oct-00
Modified: 30-May-05

DESCRIPTION:
This macro generates an expression used to evaluate whether a given condition is true
for ALL variables in a list.
The macro generates a condition expression of the form:
(Var1 = value1 | Var1 = value2 | ... | Var1 = valuen) &
(Var2 = value1 | Var2 = value2 | ... | Var2 = valuen) &
...
(Varm = value1 | Varm = value2 | ... | Varm = valuen)

The '=' sign is the default comparison operator, but it can be replaced by any other comparison
operator, such as >, <, ~=, etc.

USAGE:
%All(vars , operator, values , pairwise=0);

REQUIRED PARAMETERS:
- vars:			A list of names separated by blanks identifying the variable names used in the
				expression generated by the macro.

- comparison:	The comparison operator used in the expression generated by the macro.
				e.g.: =, >, <, >=, <=, not in, etc.

- values:		A list of values separated by blanks with which the variables in &vars are
				compared, using the comparison operator &comparison ('=' is the default operator).

OPTIONAL PARAMETERS:
- pairwise:		Whether the comparison between the variables passed in 'vars'
				and the values passed in 'values' should be done pairwise.
				In this case, the numbers of elements in 'vars' and in 'values'
				should be equal.
				See Example 3 below.
				Possible values: 0 => not pairwise, 1 => pairwise.
				default: 0

RETURNED VALUES:
The expression with the condition being evaluated for all the variables in 'vars' is returned. 

NOTES:
1.- The condition can be used in the context of a data step or within IML, but not
in the macro language, because the variable contained in parameter 'vars' are
treated as data step or IML variables, not as macro variables.
 
2.- In order to check if the value of a character variable is missing, pass ""
as parameter to 'values', with NO space between the quotation marks.
The quotation marks should be DOUBLE QUOTES, NOT single.

OTHER MACROS AND MODULES USED IN THIS MACRO:
- %GetNroElements

SEE ALSO:
- %Any
- %GetVarList
- %GetVarNames

EXAMPLES:
1.- The following statement (used inside a SAS data step):
'if %all(x y z, =, 0 .) then'
will generate the following statement:
'if ((x=0 | x=.) & (y=0 | y=.) & (z=0 | z=.)) then'.

2.- The following statement (used inside a SAS data step):
'if %all(x y, >, 0) then'
will generate the following statement:
'if ((x>0) & (y>0)) then'.

3.- The following statement (used inside a SAS data step):
'if %all(x y, >, 3 4, pairwise=1) then'
will generate the following statement:
'if ((x>3) & (y>4)) then'.

4.- Comparing character variables with missing value:
'if %all(name lastname, =, "") then'
will generate the following statement:
'if ((name="") & (lastname="")) then'.
NOTE: THERE IS NO SPACE BETWEEN THE QUOTATION MARKS, O.W. THERE AN ERROR IS GIVEN.

APPLICATIONS:
This macro avoids having to write a lengthy statement to evaluate a single
condition that must be satisfied by ALL variables in a lengthy list.

A practical example is to check for observations having missing values in all
the variables of a dataset. Assuming the list of variables in a dataset is
x y z t u v, the following statement is the one to use for this end:

'if %all(x y z t u v, =, .) then'

Note: The list of variables in a dataset can be retrieved with the macro
%GetVarNames. However, this will return ALL the variables in a dataset which
may include both numeric and character variables, and thus the use of the
above statement will yield an error when the comparison against '.' is done
for the character variables (because the missing value for a character variable
is the empty string ('""')).
In order to retrieve the list of numeric and character variables separately,
use the macro %GetVarList as follows:
%GetVarList(dataset, _NUMERIC_, macrovar=numvar);
%GetVarList(dataset, _CHAR_, macrovar=charvar);
The macro variables 'numvar' and 'charvar' will respectively contain the list of
all the numeric and all the character variables in dataset DATASET.
*/
&rsubmit;
%MACRO All(vars , operator, values, pairwise=0) / store des="Creates AND conditions";
/* IMPORTANT NOTE (30/12/03):
The operators & and | are used for AND and OR respectively so that the macro
can be used from within SAS/IML, where the logical operators are & and |, not
AND and OR. In regular SAS, & also stands for AND and | also stands for OR.
I tried adding a new parameter to the macro (such as operator=) where one
could pass the operator to be used in creating the logical expression, but
this didn't work when calling the macro from within SAS/IML, because the
operator & or | passed as parameter was first evaluated within IML and then
the macro was executed, generating a real chaos.
You definitely don't wanna try that...
*/
%local i j condition nro_var nro_values or_condition var;
%let nro_vars = %GetNroElements(&vars);
%let nro_values = %GetNroElements(&values);

%if ~&pairwise %then
	%do i = 1 %to &nro_vars;
		%let var = %scan(&vars , &i , ' ');
		%do j = 1 %to &nro_values;
			%let value = %scan(&values , &j , ' ');
			%if &j = 1 %then
				%let or_condition = %str(&var&operator&value);
			%else
				%let or_condition = &or_condition | %str(&var&operator&value);	
		%end;
		%if &i = 1 %then
			%let condition = (&or_condition);
		%else
			%let condition = &condition & (&or_condition);
	%end;
%else %do;
	%if &nro_vars ~= &nro_values %then
		%put ALL: ERROR - The number of variables and the number of values must be equal when PAIRWISE=1;
	%else
		%do i = 1 %to &nro_vars;
			%let var = %scan(&vars , &i , ' ');
			%let value = %scan(&values , &i , ' ');
			%if &i = 1 %then
				%let condition = %str(&var&operator&value);
			%else
				%let condition = &condition & %str(&var&operator&value);
		%end;
%end;
(&condition)
%MEND All;


