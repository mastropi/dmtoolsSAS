/* Categorize-Test.sas
Created: 		18-Jun-2012
Modified: 		25-Jun-2012
Author: 		Daniel Mastropietro
Description: 	Tests run on macro %Categorize
Notes:			This test code started after I changed the %Categorize macro to version 1.06 which essentially
				implement the following features:
*/

libname eci "C:\Daniel\data\pp231_ECI";

%let data = eci.em_compras_climescat;
%let target = X_CLIENTE_TIPOCONSUMIDOR;

proc surveyselect 	data=&data(keep=A_CLIENTE_ID &target N_CLIENTE_EDAD V_CLIENTE_INGRESOS V_PRODUCTO_COSTE)
					out=tofit
					samprate=10
					seed=1717;
run;
* Partition into TRAIN and VALID (the partition is identified by the SELECTED variable);
proc surveyselect data=tofit out=tofit samprate=60 seed=1313 OUTALL;
run;

/*======================================== 2012/06/18 =======================================*/
*** The data for this part of the test came from the intermediate data generated by %EvaluationChart (_EC_data_)
*** after calling the previous version 1.05 of the %Categorize macro.
*** In fact, I was working on the new 2.01 version of %EvaluationChart, which motivated the changes carried out
*** in the %Categorize macro that led to the new 1.06 version;
*** For more info on these versions see the 'Version xxx.txt' files in the Versions directory inside C:\SAS\Macros;
%Categorize(_EC_data_, out=tmp_EC_data_1, var=p1, groups=20, varcat=p1_c, log=1);

data _NULL_;
	set tmp_EC_data_1;
	where p1_quant ~= p1_cat;
run;

%Categorize(_EC_data_, out=tmp_EC_data_1, var=p1, groups=10, varcat=p1_c, both=1, value=mean, log=1);
options mprint;
%Categorize(_EC_data_, out=tmp_EC_data_1, var=p1, groups=20, varcat=p1_c, value=mean, log=1);
options nomprint;
data _NULL_;
	set tmp_EC_data_1;
	where p1_quant ~= p1_cat;
run;
** OK: 0 obs;
* Use of VARCAT= and SUFFIX=;
%Categorize(_EC_data_, out=tmp_EC_data_1, var=p1, groups=10, varcat=p1_c, suffix=_cat3, value=mean, log=1);

* DESCENDING=1;
%Categorize(_EC_data_, out=tmp_EC_data_1, var=p1, groups=10, varcat=p1_c, value=mean, descending=1, log=1);

* PERCENTILES and DESCENDING=0;
%Categorize(_EC_data_, out=tmp_EC_data_1, var=p1, percentiles=6 12 75 96, varcat=p1_c, value=mean, descending=0, log=1);
proc freq data=tmp_EC_data_1;
	tables p1_c*p1_mean / list;
run;
* PERCENTILES and DESCENDING=0;
%Categorize(_EC_data_, out=tmp_EC_data_2, var=p1, percentiles=6 12 75 96, varcat=p1_c, value=mean, descending=1, log=1);
proc freq data=tmp_EC_data_2;
	tables p1_c*p1_mean / list;
run;
** OK, the percentiles values are applied to the DECREASING values of p1 (i.e. the first group having P1_C = 1 contains 
** the TOP 6% values of p1 (as opposed to the LOWEST 6% values, which is what is done in the above case where DESCENDING=0);

*** Check parsing of LONG NAMES;
%Categorize(_EC_data_, out=tmp_EC_data_2, var=p1, varcat=p1_ckaj23lkejflkdadfkljadlsfdfasefa, value=mean, descending=1, log=1);
%Categorize(_EC_data_, out=tmp_EC_data_2, var=p1, suffix=_kladsfkjadljlasdjflkajserlkjeowjflaskdjfla, value=mean, descending=1, log=1);
%Categorize(_EC_data_, out=tmp_EC_data_2, var=p1, suffix=_thissuffixisokthissuffixisok, value=mean, descending=1, log=1);
* Combined values of VARCAT= and SUFFIX=;
%Categorize(_EC_data_, out=tmp_EC_data_2, var=p1 p1_quant, varcat=p1_c, suffix=_thissuffixisokthissuffixisok, value=mean, descending=1, log=1);
** OK!;

*** Test combination of VARCAT= and SUFFIX=;
%Categorize(_EC_data_, out=tmp_EC_data_2, var=p1 p1_quant, varcat=p1_c, suffix=_qq, value=median, descending=1, log=1);
%Categorize(_EC_data_, out=tmp_EC_data_2, var=p1 p1_quant, suffix=_qq, value=median, descending=0, log=1);
* No VARCAT option, BOTH=0 and VALUE=median;
%Categorize(_EC_data_, out=tmp_EC_data_2, var=p1 _QUANTILEGROUP__mean, suffix=_qq, both=0, value=median, descending=0, log=1);
** OK: Only the MEDIAN values are stored in the output dataset here;

*** Check the MISSING values mapping (to missing);
%Categorize(tmp_EC_data_, out=tmp_EC_data_3, var=p1 p1_quant, varcat=p1_c, suffix=_qq, descending=1, log=1);
** OK;
/*======================================== 2012/06/18 =======================================*/


/*======================================== 2012/06/20 =======================================*/
*** Tests after modifying the naming convention for the percentile values computed by PROC UNIVARIATE
*** so that long names up to 32-character long are accepted as analysis variables;

* Fit a logistic model to create a Probability variable whose name is long;
proc logistic data=tofit;
	model &target = N_CLIENTE_EDAD V_CLIENTE_INGRESOS V_PRODUCTO_COSTE / link=glogit;	** LINK=GLOGIT is used so that the target variable is considered as NOMINAL (as opposed to ORDINAL);
	output out=tofit_pred0 pred=&target._probabi;
run;
%put %length(&target._probabi);
** 32 character long;

* Categorization of multiple variables, one of them with 32 characters;
options mprint;
%Categorize(tofit_pred0, out=tmp_tofit_pred0, var=&target._probabi N_CLIENTE_EDAD, varcat=probabi_cat, suffix=_c, value=mean, descending=1, log=1);
options nomprint;
** OK;
proc sgplot data=tmp_tofit_pred0;
	vbox &target._probabi / group=probabi_cat grouporder=ascending;
run;
proc means data=tmp_tofit_pred0 mean n;
	class probabi_cat;
	var &target._probabi probabi_cat_mean;
run;
proc sgplot data=tmp_tofit_pred0;
	vbox N_CLIENTE_EDAD / group=N_CLIENTE_EDAD_c grouporder=ascending;
run;
proc means data=tmp_tofit_pred0 mean n;
	class N_CLIENTE_EDAD_c;
	var N_CLIENTE_EDAD N_CLIENTE_EDAD_c_mean;
run;
proc univariate data=tmp_tofit_pred0;
	var N_CLIENTE_EDAD;
	histogram N_CLIENTE_EDAD;
run;
** The groups look ok!;

* Replacing the original variable with the categorized one;
options mprint;
%Categorize(tofit_pred0, out=tmp_tofit_pred0, var=&target._probabi N_CLIENTE_EDAD, varcat=&target._probabi, suffix=, descending=1, log=1);
options nomprint;

*** Tests after simplifying the DROP and RENAME process done on the categorized variable at the
*** creation of the output dataset;
* Combinations of VARCAT= and SUFFIX=;
%Categorize(tofit_pred0, out=tmp_tofit_pred0, var=V_CLIENTE_INGRESOS N_CLIENTE_EDAD, varcat=V_CLIENTE_INGRESOS, suffix=_qq, value=median, descending=1, log=1);
%Categorize(tofit_pred0, out=tmp_tofit_pred1, var=V_CLIENTE_INGRESOS N_CLIENTE_EDAD, suffix=_qq, value=median, descending=0, log=1);
* No VARCAT option, BOTH=0 and VALUE=median;
%Categorize(tofit_pred0, out=tmp_tofit_pred2, var=V_CLIENTE_INGRESOS N_CLIENTE_EDAD, suffix=_qq, both=0, value=median, descending=0, log=1);
** OK: Only the MEDIAN values are stored in the output dataset here;
* No parameters are specified;
%Categorize(tofit_pred0, out=tmp_tofit_pred3, var=V_CLIENTE_INGRESOS N_CLIENTE_EDAD, log=1);
* Add BOTH;
%Categorize(tofit_pred0, out=tmp_tofit_pred4, var=V_CLIENTE_INGRESOS N_CLIENTE_EDAD, both=1, log=1);

proc sgplot data=tmp_tofit_pred4;
	vbox V_CLIENTE_INGRESOS / group=V_CLIENTE_INGRESOS_cat grouporder=ascending;
run;
proc means data=tmp_tofit_pred4 mean n;
	class V_CLIENTE_INGRESOS_cat;
	var V_CLIENTE_INGRESOS V_CLIENTE_INGRESOS_cat_mean;
run;
proc univariate data=tmp_tofit_pred4;
	var V_CLIENTE_INGRESOS;
	histogram V_CLIENTE_INGRESOS;
run;

* Check non-integer percentile values;
%Categorize(tofit_pred0, out=tmp_tofit_pred4, var=V_CLIENTE_INGRESOS N_CLIENTE_EDAD, percentiles=1.7 23.4 97.5, both=1, log=1);
proc sgplot data=tmp_tofit_pred4;
	vbox V_CLIENTE_INGRESOS / group=V_CLIENTE_INGRESOS_cat grouporder=ascending;
run;
proc means data=tmp_tofit_pred4 mean n;
	class V_CLIENTE_INGRESOS_cat;
	var V_CLIENTE_INGRESOS V_CLIENTE_INGRESOS_cat_mean;
run;
proc univariate data=tmp_tofit_pred4;
	var V_CLIENTE_INGRESOS;
	histogram V_CLIENTE_INGRESOS;
run;
/*======================================== 2012/06/20 =======================================*/



/*======================================== 2012/06/25 =======================================*/
*** Check the new formulation of the DESCENDING=1 option, where I slightly changed the %Categorize macro
*** so that always group value 1 is given to the top largest values of the analyzed variable.
*** Prior to this change, the group value = &NRO_PERCENTILES was given to the top smallest values of the analyzed
*** variable, making the value assigned to the largest values dependent of the variable distribution.
*** After this change, the effect of the DESCENDING=1 option is the same as applying the DESCENDING=0 option
*** to a new variable Y that is constructed as Y = max(X) - X where X is the original variable being categorized
*** with the DESCENDING=1 option;
*** The data used for these tests is an intermediate dataset generated by the %EvaluationChart macro (_EC_data_);

* Construct the Y = max(X) - X variable in order to test the DESCENDING=1 option;
* The X variable here is P1_LEAF_MEAN which is the probability estimated by an hypothetical decision tree model;
%GetStat(_EC_data_, var=p1_leaf_mean, stat=max);
data _EC_data_;
	set _EC_data_;
	* Y = max(X) - X: round the values of Y to the 1E-7 decimal;
	p1_leaf_mean_desc = round(&p1_leaf_mean_max - p1_leaf_mean, 1E-7);
run;
proc univariate data=_EC_data_;
	var p1_leaf_mean;
run;
options mprint;
%Categorize(_EC_data_, out=tmp_EC_data_1, var=p1_leaf_mean, groups=20, varcat=GROUP, DESCENDING=1, log=0);
options nomprint;
options mprint;
%Categorize(_EC_data_, out=tmp_EC_data_2, var=p1_leaf_mean_desc, groups=20, varcat=GROUP, DESCENDING=0, log=0);
options nomprint;
proc compare base=tmp_EC_data_1 compare=tmp_EC_data_2;
	var GROUP;
run;
** OK: All values are exactly equal => The result of categorizing the reversed values of P1_LEAF_MEAN with DESCENDING=0 is the same as the result
** of categorizing the original values P1_LEAF_MEAN with DESCENDING=1. This is what we want to obtain with
** the DESCENDING option ON;

* Same as above but using GROUPSIZE= option;
options mprint;
%Categorize(_EC_data_, out=tmp_EC_data_3, var=p1_leaf_mean, groupsize=100, varcat=GROUP, DESCENDING=1, log=0);
options nomprint;
options mprint;
%Categorize(_EC_data_, out=tmp_EC_data_4, var=p1_leaf_mean_desc, groupsize=100, varcat=GROUP, DESCENDING=0, log=0);
options nomprint;
proc compare base=tmp_EC_data_3 compare=tmp_EC_data_4;
	var GROUP;
run;
** OK: All values are exactly equal;

* Same as above but with unequally-spaced PERCENTILE values;
options mprint;
%Categorize(_EC_data_, out=tmp_EC_data_5, var=p1_leaf_mean, percentiles=4 10, varcat=GROUP, DESCENDING=1, log=0);
options nomprint;
options mprint;
%Categorize(_EC_data_, out=tmp_EC_data_6, var=p1_leaf_mean_desc, percentiles=4 10, varcat=GROUP, DESCENDING=0, log=0);
options nomprint;
proc compare base=tmp_EC_data_5 compare=tmp_EC_data_6;
	var GROUP;
run;
** OK: All values are exactly equal;
/*======================================== 2012/06/25 =======================================*/



/*======================================== 2015/08/27 =======================================*/
*** Check version 1.10 where the treatment of the VARCAT=, VARVALUE= and BOTH= parameters have been cleaned up;

* Mix new names in VARCAT= and VARVALUE= with using the default suffix (_CAT);
%Categorize(tofit(obs=100 keep=A_ID_SOLICITUD A_PERIODO N_CR_CUOTA_ALL_PAG_MAX N_CR_DDM_ACTUAL ZL_V_CR_CUOTAS_VCD_PAG_SUM),
			var=N_CR_CUOTA_ALL_PAG_MAX N_CR_DDM_ACTUAL ZL_V_CR_CUOTAS_VCD_PAG_SUM,
			groupsize=10,
			both=1,
			varcat=x1 N_CR_DDM_ACTUAL,
			value=mean,
			varvalue=N_CR_CUOTA_ALL_PAG_MAX x2,
			out=_PB_data_,
			log=1);
** OK: A message stating that the length of at least one of the categorized versions of ZL_V_CR_CUOTAS_VCD_PAG_SUM has more than 32 characters;

* Change the above call to BOTH=0 so that only the statistic-valued categorized variables are created and thus
* avoid the name problem for the long variable name, since the default _CAT suffix is not used to name it;
%Categorize(tofit(obs=100 keep=A_ID_SOLICITUD A_PERIODO N_CR_CUOTA_ALL_PAG_MAX N_CR_DDM_ACTUAL ZL_V_CR_CUOTAS_VCD_PAG_SUM),
			var=N_CR_CUOTA_ALL_PAG_MAX N_CR_DDM_ACTUAL ZL_V_CR_CUOTAS_VCD_PAG_SUM,
			groupsize=10,
			both=0,
			varcat=x1 N_CR_DDM_ACTUAL,
			value=mean,
			varvalue=N_CR_CUOTA_ALL_PAG_MAX x2,
			out=_PB_data_,
			log=1);
** OK:
** Variables N_CR_CUOTA_ALL_PAG_MAX x2 and ZL_V_CR_CUOTAS_VCD_PAG_SUM_MEAN contain the statistic-valued categorized variables;

* Set back BOTH=1 and add a third name in VARCAT in order to avoid the long name of the categorized third variable;
%Categorize(tofit(obs=100 keep=A_ID_SOLICITUD A_PERIODO N_CR_CUOTA_ALL_PAG_MAX N_CR_DDM_ACTUAL ZL_V_CR_CUOTAS_VCD_PAG_SUM),
			var=N_CR_CUOTA_ALL_PAG_MAX N_CR_DDM_ACTUAL ZL_V_CR_CUOTAS_VCD_PAG_SUM,
			groupsize=10,
			both=1,
			varcat=x1 N_CR_DDM_ACTUAL x3,
			value=mean,
			varvalue=N_CR_CUOTA_ALL_PAG_MAX x2,
			out=_PB_data_,
			log=1);
** OK:
** Variables x1 N_CR_DDM_ACTUAL x3 contain the integer-valued categorized variable.
** Variables N_CR_CUOTA_ALL_PAG_MAX x2 and x3_mean contain the statistic-valued categorized variables.
** Note that the name of the third variale is X3_MEAN and NOT the long name variable with the _MEAN suffix!;

* Check back the default behaviour with short-enough input variable names;
%Categorize(tofit(obs=100 keep=A_ID_SOLICITUD A_PERIODO N_CR_CUOTA_ALL_PAG_MAX N_CR_DDM_ACTUAL ZL_V_CR_CUOTAS_VCD_PAG_SUM),
			var=N_CR_CUOTA_ALL_PAG_MAX N_CR_DDM_ACTUAL,
			both=1,
			out=_PB_data_,
			log=1);
** OK: No errors;
/*======================================== 2015/08/27 =======================================*/
